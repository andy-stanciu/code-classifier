class Solution {

    private int findLowerBound(int x, int s, int[][] is) {
        int l = s, r = is.length - 1, lb = is.length;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (is[mid][0] < x)
                l = mid + 1;
            else {
                lb = mid;
                r = mid - 1;
            }
        }
        return lb;
    }

    private int method1(int ind, int[] dp, int[][] is) {
        if (ind == is.length)
            return 0;
        if (dp[ind] != -1)
            return dp[ind];
        int lb = findLowerBound(is[ind][1], ind + 1, is);
        int w1 = method1(lb, dp, is) + (lb - ind - 1);
        int w2 = method1(ind + 1, dp, is) + 1;
        return dp[ind] = Math.min(w1, w2);
    }

    public int method2(int[][] is) {
        Arrays.sort(is, (a, b) -> a[0] - b[0]);
        int n = is.length;
        int[] dp = new int[n];
        Arrays.fill(dp, -1);
        return method1(0, dp, is);
    }

    public int method3(int[][] is) {
        Arrays.sort(is, (a, b) -> a[0] - b[0]);
        int n = is.length, dp[] = new int[n + 1];
        for (int ind = n - 1; ind >= 0; ind--) {
            int lb = findLowerBound(is[ind][1], ind + 1, is);
            int w1 = dp[lb] + (lb - ind - 1);
            int w2 = dp[ind + 1] + 1;
            dp[ind] = Math.min(w1, w2);
        }
        return dp[0];
    }

    int method4(int[][] is) {
        Arrays.sort(is, (a, b) -> a[1] - b[1]);
        int curEndTime = Integer.MIN_VALUE, ans = 0;
        for (int i = 0; i < is.length; i++) {
            int x = is[i][0], y = is[i][1];
            if (curEndTime <= x)
                curEndTime = y;
            else
                ans++;
        }
        return ans;
    }
}
