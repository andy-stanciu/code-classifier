class Solution {

    public int[] findOrder(int param1, int[][] prerequisites) {
        int[] ans = new int[param1];
        int[] incomingEdges = new int[param1];
        List<Integer>[] graph = new ArrayList[param1];
        for (int i = 0; i < graph.length; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] pre : prerequisites) {
            int u = pre[0];
            int v = pre[1];
            graph[v].add(u);
            incomingEdges[u]++;
        }
        int idx = 0;
        Queue<Integer> que = new ArrayDeque<>();
        for (int i = 0; i < incomingEdges.length; i++) {
            if (incomingEdges[i] == 0) {
                que.add(i);
                ans[idx] = i;
                idx++;
            }
        }
        while (que.size() > 0) {
            int independentNode = que.poll();
            for (int i = 0; i < graph[independentNode].size(); i++) {
                int v = graph[independentNode].get(i);
                incomingEdges[v]--;
                if (incomingEdges[v] == 0) {
                    que.add(v);
                    ans[idx] = v;
                    idx++;
                }
            }
        }
        boolean solved = false;
        for (int i = 0; i < incomingEdges.length; i++) {
            if (incomingEdges[i] != 0) {
                return new int[0];
            }
        }
        return ans;
    }
}
