class Solution {

    int time = 0;

    public int[] findOrder(int param1, int[][] prerequisites) {
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < param1; i++) adj.add(new ArrayList<Integer>());
        for (int[] i : prerequisites) adj.get(i[1]).add(i[0]);
        int[] d = new int[param1];
        int[] f = new int[param1];
        Arrays.fill(d, -1);
        Arrays.fill(f, -1);
        int[] finishing = new int[param1];
        Stack<Integer> stack = new Stack<Integer>();
        for (int var1 = 0; var1 < param1; var1++) {
            if (d[var1] == -1) {
                if (dfs(adj, d, f, stack, var1) == false)
                    return new int[0];
            } else {
                assert f[var1] != -1;
                continue;
            }
        }
        for (int i = 0; i < param1; i++) {
            finishing[i] = stack.pop();
        }
        return finishing;
    }

    public boolean dfs(List<List<Integer>> adj, int[] d, int[] f, Stack<Integer> stack, int var1) {
        d[var1] = time++;
        for (int dep : adj.get(var1)) {
            if (d[dep] != -1) {
                if (f[dep] == -1)
                    return false;
            } else {
                if (dfs(adj, d, f, stack, dep) == false)
                    return false;
            }
        }
        f[var1] = time++;
        stack.push(var1);
        return true;
    }
}
