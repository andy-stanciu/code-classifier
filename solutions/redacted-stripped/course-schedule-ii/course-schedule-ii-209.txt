class Solution {

    ArrayList<Stack<Integer>> list;

    boolean[] isVisited;

    int[] ans;

    int pointer = 0;

    public int[] findOrder(int param1, int[][] prerequisites) {
        this.list = new ArrayList<>();
        this.isVisited = new boolean[param1];
        this.ans = new int[param1];
        for (int i = 0; i < param1; i++) list.add(new Stack());
        for (int i = 0; i < prerequisites.length; i++) {
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            list.get(a).push(b);
        }
        for (int i = 0; i < param1; i++) {
            if (!dfs(i))
                return new int[0];
        }
        return ans;
    }

    private boolean dfs(int n) {
        Stack<Integer> stack = list.get(n);
        if (isVisited[n])
            return stack.isEmpty() ? true : false;
        isVisited[n] = true;
        while (!stack.isEmpty()) {
            boolean ans = dfs(stack.peek());
            stack.pop();
            if (!ans)
                return false;
        }
        ans[pointer++] = n;
        return true;
    }
}
