class Solution {

    public int rec(int indx, int target, int[] arr) {
        if (indx == 0) {
            if (target % arr[0] == 0)
                return target / arr[0];
            else
                return (int) Math.pow(10, 9);
        }
        int nottaken = (int) Math.pow(10, 9);
        int taken = (int) Math.pow(10, 9);
        if (indx >= 1)
            nottaken = rec(indx - 1, target, arr);
        if (arr[indx] <= target)
            taken = 1 + rec(indx, target - arr[indx], arr);
        return Math.min(taken, nottaken);
    }

    public int memo(int indx, int target, int[] arr, int[][] dp) {
        if (indx == 0) {
            if (target % arr[0] == 0)
                return target / arr[0];
            else
                return (int) Math.pow(10, 9);
        }
        if (dp[indx][target] != -1)
            return dp[indx][target];
        int nottaken = (int) Math.pow(10, 9);
        int taken = (int) Math.pow(10, 9);
        if (indx >= 1)
            nottaken = rec(indx - 1, target, arr);
        if (arr[indx] <= target)
            taken = 1 + rec(indx, target - arr[indx], arr);
        dp[indx][target] = Math.min(taken, nottaken);
        return dp[indx][target];
    }

    public static int tab(int indx, int target, int[] arr, int[][] dp) {
        for (int i = 0; i <= target; i++) {
            if (i % arr[0] == 0)
                dp[0][i] = i / arr[0];
            else
                dp[0][i] = (int) Math.pow(10, 9);
        }
        int nottaken = (int) Math.pow(10, 9);
        int taken = (int) Math.pow(10, 9);
        for (int i = 1; i <= indx; i++) {
            for (int j = 0; j <= target; j++) {
                if (i >= 1)
                    nottaken = dp[i - 1][j];
                if (arr[i] <= j)
                    taken = 1 + dp[i][j - arr[i]];
                dp[i][j] = Math.min(taken, nottaken);
            }
        }
        return dp[indx][target];
    }

    public int memo1(int indx, int target, int[] arr, int[][] dp) {
        if (indx == 0) {
            if (target % arr[0] == 0)
                return target / arr[0];
            else
                return (int) Math.pow(10, 9);
        }
        if (dp[indx][target] != -1)
            return dp[indx][target];
        int nottaken = (int) Math.pow(10, 9);
        int taken = (int) Math.pow(10, 9);
        if (indx >= 1)
            nottaken = rec(indx - 1, target, arr);
        if (arr[indx] <= target)
            taken = 1 + rec(indx, target - arr[indx], arr);
        dp[indx][target] = Math.min(taken, nottaken);
        return dp[indx][target];
    }

    public static int optimal(int indx, int target, int[] arr) {
        int[] prev = new int[target + 1];
        for (int i = 0; i <= target; i++) {
            if (i % arr[0] == 0)
                prev[i] = i / arr[0];
            else
                prev[i] = (int) Math.pow(10, 9);
        }
        int nottaken = (int) Math.pow(10, 9);
        int taken = (int) Math.pow(10, 9);
        for (int i = 1; i <= indx; i++) {
            int[] curr = new int[target + 1];
            for (int j = 0; j <= target; j++) {
                if (i >= 1)
                    nottaken = prev[j];
                if (arr[i] <= j)
                    taken = 1 + curr[j - arr[i]];
                curr[j] = Math.min(taken, nottaken);
            }
            prev = curr;
        }
        return prev[target];
    }

    public int method1(int[] param1, int amount) {
        int[][] dp = new int[param1.length][amount + 1];
        int ans = optimal(param1.length - 1, amount, param1);
        if (ans >= (int) Math.pow(10, 9))
            return -1;
        else
            return ans;
    }
}
