class Solution {

    public boolean canFinish(int param1, int[][] prerequisites) {
        Map<Integer, List<Integer>> adjacency = new HashMap<>();
        Map<Integer, Integer> in_degree = new HashMap<>();
        initMaps(adjacency, in_degree, param1, prerequisites);
        Deque<Integer> queue = new ArrayDeque<>();
        for (Map.Entry<Integer, Integer> entry : in_degree.entrySet()) {
            if (entry.getValue() == 0) {
                queue.offer(entry.getKey());
            }
        }
        int processed = 0;
        while (!queue.isEmpty()) {
            int var1 = queue.pollFirst();
            processed++;
            List<Integer> neighbors = adjacency.get(var1);
            if (neighbors != null) {
                for (int neighbor : neighbors) {
                    in_degree.put(neighbor, in_degree.get(neighbor) - 1);
                    if (in_degree.get(neighbor) == 0) {
                        queue.offer(neighbor);
                    }
                }
            }
        }
        return processed == param1;
    }

    private void initMaps(Map<Integer, List<Integer>> adjacency, Map<Integer, Integer> in_degree, int param1, int[][] prerequisites) {
        for (int i = 0; i < param1; i++) {
            in_degree.put(i, 0);
            adjacency.put(i, new ArrayList<>());
        }
        for (int[] prerequisite : prerequisites) {
            int source = prerequisite[1];
            int target = prerequisite[0];
            adjacency.get(source).add(target);
            in_degree.put(target, in_degree.get(target) + 1);
        }
    }
}
