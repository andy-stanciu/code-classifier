class Pair {

    TreeNode node;

    String str;

    Pair(TreeNode node, String str) {
        this.node = node;
        this.str = str;
    }
}

class Solution {

    public boolean isPali(ArrayList<Pair> lis) {
        int i = 0, j = lis.size() - 1;
        while (i < j) {
            if ((lis.get(i).node.val != lis.get(j).node.val) || (lis.get(i).str.equals("left") && lis.get(j).str.equals("left")) || (lis.get(i).str.equals("right") && lis.get(j).str.equals("right"))) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    public boolean solve(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<Pair> q = new LinkedList<>();
        q.offer(new Pair(root, ""));
        TreeNode dumb = new TreeNode(-1000000);
        while (!q.isEmpty()) {
            int size = q.size();
            ArrayList<Pair> lis = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                Pair rem = q.poll();
                if (rem.node.val == -1000000) {
                    lis.add(new Pair(rem.node, rem.str));
                    continue;
                }
                if (rem.str.length() != 0) {
                    lis.add(new Pair(rem.node, rem.str));
                }
                if (rem.node.left != null) {
                    q.offer(new Pair(rem.node.left, "left"));
                } else {
                    q.offer(new Pair(dumb, "left"));
                }
                if (rem.node.right != null) {
                    q.offer(new Pair(rem.node.right, "right"));
                } else {
                    q.offer(new Pair(dumb, "right"));
                }
            }
            if (!isPali(lis)) {
                return false;
            }
        }
        return true;
    }

    public boolean method1(TreeNode root) {
        return solve(root);
    }
}
