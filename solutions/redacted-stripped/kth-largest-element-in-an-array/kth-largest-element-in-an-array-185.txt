public class Solution {

    private int parent(int pos) {
        return pos > 1 ? pos / 2 : -1;
    }

    private boolean isLeaf(int[] heap, int pos) {
        return pos > heap.length / 2 && pos <= heap.length;
    }

    private int leftChild(int pos) {
        return (2 * pos);
    }

    private int rightChild(int pos) {
        return (2 * pos) + 1;
    }

    private void method1(int[] heap, int pos, int heapSize) {
        if (!isLeaf(heap, pos) && pos <= heapSize / 2) {
            int left = leftChild(pos);
            int right = rightChild(pos);
            int smallest = pos;
            if (left <= heapSize && heap[left] < heap[smallest])
                smallest = left;
            if (right <= heapSize && heap[right] < heap[smallest])
                smallest = right;
            if (smallest != pos) {
                swap(heap, pos, smallest);
                method1(heap, smallest, heapSize);
            }
        }
    }

    private void swap(int[] heap, int fpos, int spos) {
        int tmp = heap[fpos];
        heap[fpos] = heap[spos];
        heap[spos] = tmp;
    }

    private void method2(int[] heap, int param1, int pos, int k) {
        if (pos > k) {
            if (param1 > heap[1]) {
                heap[1] = param1;
                method1(heap, 1, k);
            }
        } else {
            heap[pos] = param1;
            int current = pos;
            while (parent(current) > 0 && heap[current] < heap[parent(current)]) {
                swap(heap, current, parent(current));
                current = parent(current);
            }
        }
    }

    public int method3(int[] nums, int k) {
        int[] heap = new int[k + 1];
        heap[0] = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++) {
            method2(heap, nums[i], i + 1, k);
        }
        return heap[1];
    }
}
