class Solution {

    public static double myPow(double x, int n) {
        double ans = pow(x, n, n);
        /*the first "n" would be used for recursive calls
          while we won\'t change the second "n", so as we
          can check anytime , if the power was NEGATIVE
        */
        return ans;
    }

    public static double pow(double x, int n, int k) {
        //base condition
        if (n == 0)
            return 1;
        double help = pow(x, n / 2, k), ans = 0;
        /* instead of recursively calling pow() 2 times
        we can just store its value and the use it twice
        it would reduce the TIME
        */
        ans = help * help;
        if (n % 2 != 0) {
            ans = x * ans;
        }
        /* If you have reached the end while backtracking
        your recursive calls, you just to check if N was 
        negative , if it is so, then return 1/ans  else
        return ans;
        */
        if (k < 0 && n == k)
            return 1 / ans;
        return ans;
    }
}
//BRUTE FORCE :-
//(Stack overflows at higher values);
/*  public static double pow(double x,int n,int k){
       if(n==0){
        return 1;
       }
       if(k<0){
        if(n==k){
            return 1/(x*pow(x,n+1,k));
        }
        else{
        return x*pow(x,n+1,k);
       }
    }
    else{
        return x*pow(x,n-1,k);
    }
}
}
*/
