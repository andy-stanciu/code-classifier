class Solution {

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Perform topological sort
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        Set<Integer> visited = new HashSet<>();
        // Used for cycle detection
        Set<Integer> recursionStack = new HashSet<>();
        // Initialize the adjacency list
        for (int[] pair : prerequisites) {
            graph.computeIfAbsent(pair[1], k -> new ArrayList<>()).add(pair[0]);
        }
        // Perform topological sorting with cycle detection
        for (int i = 0; i < numCourses; i++) {
            if (!visited.contains(i)) {
                if (hasCycle(graph, visited, recursionStack, stack, i)) {
                    return new int[0];
                }
            }
        }
        // Convert stack to result array
        int[] result = new int[numCourses];
        int index = 0;
        while (!stack.isEmpty()) {
            result[index++] = stack.pop();
        }
        return result;
    }

    private boolean hasCycle(Map<Integer, List<Integer>> graph, Set<Integer> visited, Set<Integer> recursionStack, Stack<Integer> stack, int node) {
        if (recursionStack.contains(node)) {
            // Cycle detected
            return true;
        }
        if (visited.contains(node)) {
            // Node already processed
            return false;
        }
        visited.add(node);
        recursionStack.add(node);
        for (int neighbor : graph.getOrDefault(node, new ArrayList<>())) {
            if (hasCycle(graph, visited, recursionStack, stack, neighbor)) {
                return true;
            }
        }
        recursionStack.remove(node);
        stack.push(node);
        return false;
    }
}
