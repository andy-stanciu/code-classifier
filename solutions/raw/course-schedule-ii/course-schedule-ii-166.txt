class Solution {

    List<List<Integer>> adjList = new ArrayList<>();

    boolean[] inStack;

    boolean[] visited;

    Stack<Integer> stack = new Stack<>();

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        for (int i = 0; i < numCourses; i++) adjList.add(new ArrayList<>());
        for (int[] prerequisite : prerequisites) adjList.get(prerequisite[1]).add(prerequisite[0]);
        inStack = new boolean[numCourses];
        visited = new boolean[numCourses];
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            if (dfs(i))
                return new int[0];
        }
        int[] res = new int[numCourses];
        int i = 0;
        while (!stack.isEmpty()) res[i++] = stack.pop();
        return res;
    }

    //dfs -> returns if there is a back edge
    public boolean dfs(int num) {
        if (// if it is present in the stack currently, this is a back edge
        inStack[num])
            return true;
        if (//we visited it earlier, but didn\'t find a back edge
        visited[num])
            return false;
        inStack[num] = true;
        visited[num] = true;
        List<Integer> neighbors = adjList.get(num);
        for (int neighbor : neighbors) {
            if (dfs(neighbor))
                return true;
        }
        inStack[num] = false;
        //all the neighbors of this neighbor have been traversed,
        //need to pull it out of the current stack
        stack.push(num);
        return false;
    }
}
