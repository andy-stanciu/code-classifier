class Solution {

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < prerequisites.length; i++) {
            adj.get(prerequisites[i][0]).add(prerequisites[i][1]);
        }
        int[] arr = new int[numCourses];
        HashSet<Integer> visited = new HashSet<>();
        for (int i = 0; i < numCourses; i++) {
            if (!visited.contains(i)) {
                dfs(adj, visited, i);
            }
        }
        //        boolean[]vis=new boolean[numCourses];
        if (st.size() == numCourses && !detectCycle(numCourses, adj)) {
            int i = numCourses - 1;
            while (st.size() > 0) {
                arr[i--] = st.pop();
            }
            return arr;
        } else
            return new int[] {};
    }

    Stack<Integer> st = new Stack<>();

    public void dfs(ArrayList<ArrayList<Integer>> adj, HashSet<Integer> visited, int src) {
        visited.add(src);
        for (int v : adj.get(src)) {
            if (!visited.contains(v)) {
                dfs(adj, visited, v);
            }
        }
        st.add(src);
    }

    private boolean detectCycle(int n, ArrayList<ArrayList<Integer>> adj) {
        int[] visited = new int[n];
        for (int i = 0; i < n; ++i) if (visited[i] == 0) {
            if (detectCycle_util(adj, visited, i))
                return true;
        }
        return false;
    }

    private boolean detectCycle_util(ArrayList<ArrayList<Integer>> adj, int[] visited, int v) {
        if (visited[v] == 1)
            return true;
        if (visited[v] == 2) {
            return false;
        }
        //mark visited
        visited[v] = 1;
        for (int u : adj.get(v)) {
            if (detectCycle_util(adj, visited, u))
                return true;
        }
        visited[v] = 2;
        return false;
    }
}
