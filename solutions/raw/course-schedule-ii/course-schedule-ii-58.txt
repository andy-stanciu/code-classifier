// Node class representing a course
class Node {

    int val;

    List<Node> neighbors;

    public Node(int val) {
        this.val = val;
        this.neighbors = new ArrayList<>();
    }
}

public class Solution {

    // Step 1: Build the graph based on prerequisites
    public Map<Integer, Node> buildGraph(int numCourses, int[][] prerequisites) {
        // Create a map to store each course as a Node
        Map<Integer, Node> graph = new HashMap<>();
        // Initialize all nodes
        for (int i = 0; i < numCourses; i++) {
            graph.put(i, new Node(i));
        }
        // Create edges between courses based on prerequisites
        for (int[] prerequisite : prerequisites) {
            int course = prerequisite[0];
            int prerequisiteCourse = prerequisite[1];
            graph.get(prerequisiteCourse).neighbors.add(graph.get(course));
        }
        return graph;
    }

    // Step 2: Topological Sort function using Kahn\'s Algorithm
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Build the graph
        Map<Integer, Node> graph = buildGraph(numCourses, prerequisites);
        Map<Node, Integer> inDegree = new HashMap<>();
        // Initialize in-degree map for all courses
        for (Node node : graph.values()) {
            inDegree.put(node, 0);
        }
        // Calculate in-degree for all courses (number of prerequisites)
        for (Node node : graph.values()) {
            for (Node neighbor : node.neighbors) {
                inDegree.put(neighbor, inDegree.get(neighbor) + 1);
            }
        }
        // Queue to store nodes with 0 in-degree (no prerequisites)
        Queue<Node> queue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        // Enqueue courses with no prerequisites
        for (Node node : graph.values()) {
            if (inDegree.get(node) == 0) {
                queue.add(node);
            }
        }
        // Perform topological sort
        while (!queue.isEmpty()) {
            Node current = queue.poll();
            result.add(current.val);
            for (Node neighbor : current.neighbors) {
                inDegree.put(neighbor, inDegree.get(neighbor) - 1);
                if (inDegree.get(neighbor) == 0) {
                    queue.add(neighbor);
                }
            }
        }
        // Check for cycles (if we couldn\'t process all courses)
        if (result.size() != numCourses) {
            // Cycle detected, return an empty array
            return new int[0];
        }
        // Convert result list to an array and return
        return result.stream().mapToInt(i -> i).toArray();
    }
}
