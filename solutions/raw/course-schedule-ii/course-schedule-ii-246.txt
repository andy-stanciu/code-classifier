class Solution {

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // Create an adjacency list to represent the graph
        List<Integer>[] adjList = new ArrayList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            adjList[i] = new ArrayList<>();
        }
        // Populate the adjacency list with prerequisites
        for (int[] prereq : prerequisites) {
            // prereq[1] is a prerequisite for prereq[0]
            adjList[prereq[1]].add(prereq[0]);
        }
        int[] visited = new int[numCourses];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0 && !dfs(i, visited, adjList, stack)) {
                // Return an empty array if a cycle is detected
                return new int[0];
            }
        }
        int[] order = new int[numCourses];
        int index = 0;
        while (!stack.isEmpty()) {
            order[index++] = stack.pop();
        }
        return order;
    }

    private boolean dfs(int course, int[] visited, List<Integer>[] adjList, Stack<Integer> stack) {
        // Mark as visiting
        visited[course] = 1;
        for (int nextCourse : adjList[course]) {
            if (visited[nextCourse] == 1) {
                // Cycle detected
                return false;
            }
            if (visited[nextCourse] == 0 && !dfs(nextCourse, visited, adjList, stack)) {
                return false;
            }
        }
        // Mark as visited
        visited[course] = 2;
        stack.push(course);
        return true;
    }
}
