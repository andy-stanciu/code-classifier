class Solution {

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // HashMap to store the adjacency list of courses
        HashMap<Integer, List<Integer>> adjacencyListOfCourses = new HashMap<>();
        // HashMap to store the prerequisites of each course
        HashMap<Integer, HashSet<Integer>> coursePrerequisites = new HashMap<>();
        // Construct adjacency list and prerequisites map
        for (int[] pre : prerequisites) {
            int courseToBeFinishFirst = pre[1];
            int courseToBeFinishAfter = pre[0];
            // Construct adjacency list
            List<Integer> list = adjacencyListOfCourses.getOrDefault(courseToBeFinishFirst, new ArrayList<>());
            list.add(courseToBeFinishAfter);
            adjacencyListOfCourses.put(courseToBeFinishFirst, list);
            // Construct course prerequisites set
            HashSet<Integer> prerequisiteSet = coursePrerequisites.getOrDefault(courseToBeFinishAfter, new HashSet<>());
            prerequisiteSet.add(courseToBeFinishFirst);
            coursePrerequisites.put(courseToBeFinishAfter, prerequisiteSet);
        }
        // Array to store the result
        int[] result = new int[numCourses];
        // Position pointer in the result array
        int pos = 0;
        // Stack to perform DFS
        Deque<Integer> stack = new ArrayDeque<>();
        // Find courses without prerequisites and push them onto the stack
        for (int i = 0; i < numCourses; i++) {
            if (!coursePrerequisites.containsKey(i)) {
                stack.push(i);
            }
        }
        // Perform DFS
        while (!stack.isEmpty()) {
            // Take the course from the top of the stack
            int current = stack.pop();
            // Add it to the result
            result[pos++] = current;
            // Get the neighbours (courses that depend on the current course)
            List<Integer> neighbours = adjacencyListOfCourses.getOrDefault(current, new ArrayList<>());
            for (int neighbour : neighbours) {
                HashSet<Integer> prereqs = coursePrerequisites.get(neighbour);
                // Remove the current course from the prerequisites of its neighbours
                prereqs.remove(current);
                if (prereqs.isEmpty()) {
                    // If all prerequisites are fulfilled
                    // Add the neighbour to the stack for processing
                    stack.push(neighbour);
                }
            }
        }
        // If all courses can be taken, return the result; otherwise, return an empty array
        return (pos == numCourses) ? result : new int[0];
    }
}
