// In this questions, writing base case is very very crucial....
class Solution {

    // Memoization Code
    // Time Complexity : O(n)
    // Space Compelxity : O(n + n*(sum+1))... Recursive Stack Space + DP-DS
    private static int fun(int index, int[] nums, int sum, int[][] dp) {
        // Base Case
        if (index < 0) {
            return (sum == 0) ? 1 : 0;
        }
        if (dp[index][sum] != -1)
            return dp[index][sum];
        // notPick
        int notPick = fun(index - 1, nums, sum, dp);
        // pick
        int pick = 0;
        if (nums[index] <= sum)
            pick = fun(index - 1, nums, sum - nums[index], dp);
        return dp[index][sum] = notPick + pick;
    }

    public int findTargetSumWays(int[] nums, int target) {
        int len = nums.length, totalSum = Arrays.stream(nums).sum();
        // Base Case
        if ((totalSum + target) % 2 != 0 || totalSum < target)
            return 0;
        // Code
        int sum = (totalSum - target) / 2;
        int[][] dp = new int[len][sum + 1];
        Arrays.stream(dp).forEach(a -> Arrays.fill(a, -1));
        return fun(len - 1, nums, sum, dp);
    }
}
