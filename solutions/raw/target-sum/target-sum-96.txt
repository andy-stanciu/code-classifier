class Solution {

    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int i : nums) {
            sum += i;
        }
        if (Math.abs(target) > sum)
            return 0;
        //Let s1 and s2 be 2 subsets who\'s diff is target T and sum is S then
        //s1 +s2 =S
        //s1-s2 =T
        // 2*s1 = S+T  //add both equations
        //2*s2 = S-T // subtract both
        //from above 2 equations its clear both shoud be even , as they are mutiple of 2 ,
        //hence this condition
        if ((target + sum) % 2 != 0 || (sum - target) % 2 != 0)
            return 0;
        int reqSum = (-target + sum) / 2;
        int[][] mem = new int[nums.length][reqSum + 1];
        for (int i = 0; i < mem.length; i++) {
            Arrays.fill(mem[i], -1);
        }
        // return rec(0,nums,reqSum,sum,mem);
        return subsetSum(nums, nums.length, reqSum);
    }

    int subsetSum(int[] a, int n, int sum) {
        // Initializing the matrix
        int[][] dp = new int[n][sum + 1];
        if (a[0] <= sum) {
            dp[0][a[0]] = 1;
        }
        if (a[0] == 0) {
            //as we can take 0 or leave 0
            dp[0][0] = 2;
        } else {
            dp[0][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= sum; j++) {
                dp[i][j] = dp[i - 1][j];
                if (a[i] <= j) {
                    dp[i][j] += dp[i - 1][j - a[i]];
                }
            }
        }
        return dp[n - 1][sum];
    }

    int rec(int pos, int[] nums, int target, int sum, int[][] mem) {
        if (pos == nums.length) {
            if (target == 0)
                return 1;
            return 0;
        }
        if (mem[pos][target] != -1)
            return mem[pos][target];
        int take = 0;
        if (target >= nums[pos]) {
            take = rec(pos + 1, nums, target - nums[pos], sum, mem);
        }
        int nonTake = rec(pos + 1, nums, target, sum, mem);
        mem[pos][target] = nonTake + take;
        return mem[pos][target];
    }
}
