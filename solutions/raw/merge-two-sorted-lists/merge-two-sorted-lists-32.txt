/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        //If list1 is null means list2 is already sorted
        if (list1 == null) {
            return list2;
        }
        //If list2 is null means list1 is already sorted
        if (list2 == null) {
            return list1;
        }
        //Two Temporary variable to store the head of the goven linked list
        ListNode t1 = list1;
        ListNode t2 = list2;
        //ansHead and ansTail will store answer list
        ListNode ansHead = null;
        ListNode ansTail = null;
        //to find the head of the answer linked list
        if (t1.val <= t2.val) {
            //set head and tail
            ansHead = t1;
            ansTail = t1;
            t1 = t1.next;
        } else {
            //set head and tail
            ansHead = t2;
            ansTail = t2;
            t2 = t2.next;
        }
        //Till now we have decided the first element of the linked list
        //now run a loop till at least one of them has reaced to end or both
        while (t1 != null && t2 != null) {
            if (t1.val <= t2.val) {
                //if value in t1 is less than that of t2
                //add t1 node in answer tail
                ansTail.next = t1;
                //after adding new element the answer tail will move to next
                ansTail = ansTail.next;
                //as you have visited the current t1 node move t1 to t1.next
                t1 = t1.next;
            } else {
                //add t2 node in answer tail
                ansTail.next = t2;
                //after adding new element the answer tail will move to next
                ansTail = ansTail.next;
                //as you have visited the current t1 node move t1 to t1.next
                t2 = t2.next;
            }
        }
        //If one of the lis is empty then remaining list between t1 and t2 is alread sorted
        if (t1 != null) {
            ansTail.next = t1;
        } else {
            ansTail.next = t2;
        }
        return ansHead;
    }
}
