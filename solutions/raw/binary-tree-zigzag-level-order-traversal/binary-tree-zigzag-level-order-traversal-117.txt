/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null)
            return result;
        // Add everything to result from left to right using BFS and then reverse every 2nd value before returning
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean leftToRight = true;
        while (!queue.isEmpty()) {
            int qSize = queue.size();
            Deque<Integer> levelVals = new LinkedList<>();
            for (int i = 0; i < qSize; i++) {
                TreeNode node = queue.poll();
                // Using dequeue to insert either in front or last based on the flag
                // In another solution, I added them to list and reversed it, even though the time complexity would be O(n) in both cases, this might be faster as there won\'t be overhead for the reverse operation.
                if (leftToRight) {
                    levelVals.addLast(node.val);
                } else {
                    levelVals.addFirst(node.val);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(new ArrayList<>(levelVals));
            leftToRight = !leftToRight;
        }
        return result;
    }
}
