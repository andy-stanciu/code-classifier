/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// //solution 1
// class Solution {
//      public List<List<Integer>> pathSum(TreeNode root, int targetsum) {
//          List<List<Integer>> res = new ArrayList<>();
//          if (root == null) return res; // non-null judgment
//          List<Integer> path = new LinkedList<>();
//          preorderdfs(root, targetsum, res, path);
//          return res;
//      }
//      public void preorderdfs(TreeNode root, int targetsum, List<List<Integer>> res, List<Integer> path) {
//          path. add(root. val);
//          // Encountered a leaf node
//          if (root. left == null && root. right == null) {
//              // found the path with targetsum
//              if (targetsum - root.val == 0) {
//                  res.add(new ArrayList<>(path));
//              }
//              return; // If the sum is not targetsum, return
//          }
//          if (root. left != null) {
//              preorderdfs(root. left, targetsum - root. val, res, path);
//              path.remove(path.size() - 1); // backtrace
//          }
//          if (root. right != null) {
//              preorderdfs(root.right, targetsum - root.val, res, path);
//              path.remove(path.size() - 1); // backtrace
//          }
//      }
// }
// Solution 2
class Solution {

    List<List<Integer>> result;

    LinkedList<Integer> path;

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        result = new LinkedList<>();
        path = new LinkedList<>();
        travesal(root, targetSum);
        return result;
    }

    private void travesal(TreeNode root, int count) {
        if (root == null)
            return;
        path.offer(root.val);
        count -= root.val;
        if (root.left == null && root.right == null && count == 0) {
            result.add(new LinkedList<>(path));
        }
        travesal(root.left, count);
        travesal(root.right, count);
        // Backtracking
        path.removeLast();
    }
}
