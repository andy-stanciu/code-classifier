class Solution {

    public List<List<Integer>> res;

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        res = new ArrayList();
        if (root == null)
            return res;
        helper(root, targetSum, new ArrayList(), 0);
        return res;
    }

    public void helper(TreeNode root, int targetSum, List<Integer> path, int pathsm) {
        if (root.left == null && root.right == null) {
            pathsm += root.val;
            if (pathsm == targetSum) {
                List<Integer> bcase = new ArrayList();
                // New list is required because after adding path list to the res list, only the address of path list will be stored there so any change in path list through the other paths, it gets change in the res list also. That\'s why whole new list is required so that any change in path list will not be reflected in res list.
                for (int i = 0; i < path.size(); i++) {
                    bcase.add(path.get(i));
                }
                bcase.add(root.val);
                res.add(bcase);
            }
            return;
        }
        path.add(root.val);
        if (root.left != null)
            helper(root.left, targetSum, path, pathsm + root.val);
        if (root.right != null)
            helper(root.right, targetSum, path, pathsm + root.val);
        path.remove(path.size() - 1);
        // Removal is compulsary because list gets stored in heap not stack so its value remains same at every path therefore after addition of current root value we need to remove it just before exiting from that node.
        return;
    }
}
