/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> result = new ArrayList();
        List<Integer> output = new ArrayList();
        if (root == null) {
            return result;
        }
        dfs(root, targetSum, result, output);
        return result;
    }

    private void dfs(TreeNode node, int targetSum, List<List<Integer>> result, List<Integer> output) {
        if (node == null) {
            return;
        }
        output.add(node.val);
        if (node.val == targetSum && node.left == null && node.right == null) {
            result.add(output);
            return;
        }
        dfs(node.left, targetSum - node.val, result, new ArrayList<>(output));
        dfs(node.right, targetSum - node.val, result, new ArrayList<>(output));
    }
}
/*
1. We intialize an array list result first which has a list inside a list. 
2. if the root is equal to the target sum and the root is a leaf node then we add that value into the array list. 
3. Otherwise we call on the left or the right side and if we do not get null from the left side then we add it to the array list. 
4. We repeat a similar process for the right side as well.

*/
