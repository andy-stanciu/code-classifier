class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        HashSet<List<Integer>> ans = new HashSet<>();
        Sum(0, candidates, target, 0, new ArrayList<Integer>(), ans);
        return new ArrayList<>(ans);
    }

    public void Sum(int i, int[] arr, int target, int sum, List<Integer> ds, Set<List<Integer>> res) {
        if (sum == target) {
            res.add(new ArrayList<>(ds));
            return;
        }
        if (i >= arr.length || sum > target) {
            return;
        }
        //adding  first element in my list
        ds.add(arr[i]);
        //pick
        Sum(i + 1, arr, target, sum + arr[i], ds, res);
        //we will first remove the last element we added then we not go to the right side of recursive tree, not pick side
        ds.remove(ds.size() - 1);
        while (i + 1 < arr.length && arr[i] == arr[i + 1]) {
            //skipping duplicates
            i++;
        }
        //not pick
        Sum(i + 1, arr, target, sum, ds, res);
    }
}
