class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        int n = candidates.length;
        System.out.println(n);
        List<List<Integer>> ans = new ArrayList<>();
        ArrayDeque<Integer> list = new ArrayDeque<>();
        solve(0, target, candidates, list, ans);
        return ans;
    }

    private void solve(int i, int target, int[] arr, ArrayDeque<Integer> list, List<List<Integer>> ans) {
        if (target == 0) {
            ans.add(new ArrayList<>(list));
            return;
        }
        if (i >= arr.length) {
            return;
        }
        if (arr[i] > target)
            return;
        list.addLast(arr[i]);
        int ub = upperBound(arr, arr[i]);
        solve(i + 1, target - arr[i], arr, list, ans);
        list.removeLast();
        //not take
        solve(ub, target, arr, list, ans);
    }

    public int upperBound(int[] arr, int x) {
        int n = arr.length;
        int i = 0, j = n - 1, ans = -1;
        while (i <= j) {
            int mid = (i + j) / 2;
            if (arr[mid] <= x) {
                i = mid + 1;
                ans = mid;
            } else {
                j = mid - 1;
            }
        }
        return ans + 1;
    }
}
//TC- NlogN + 2^N * logN* k
