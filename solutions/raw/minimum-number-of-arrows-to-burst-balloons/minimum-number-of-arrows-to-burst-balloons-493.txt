class Solution {

    public int findMinArrowShots(int[][] points) {
        //here we are checking if the previous end point is between the current starting and ending point then we can burst these balloons with the same arrow else we have to use another one
        //to do that we have to sort according to ending points of the intervals
        //in merging we were checking if current start was smaller than previos end
        //see there we were checking on based of starting points but in this problem we are
        //checking on based of ending points
        Arrays.sort(points, (a, b) -> a[1] - b[1]);
        //eg 2,8 and 1,9 if we sort on starting points then we would require 2 arrows if on
        //ending points we would require only 1 arrow
        //as to burst points[0]
        int arrow = 1;
        //prev interval\'s end
        int prev = points[0][1];
        for (int i = 1; i < points.length; i++) {
            //traversing the points array from 1st index
            if (prev >= points[i][0] && prev <= points[i][1]) {
                //if the prev is between the next interval range it means we can burst that
                continue;
                //balloon using that same arrow hence continue
            }
            //increment the arrow required as the prev end is not between the current\'s range
            arrow++;
            //and we have to now check for the new end
            prev = points[i][1];
            //which will be current\'s end
        }
        return arrow;
    }
}
