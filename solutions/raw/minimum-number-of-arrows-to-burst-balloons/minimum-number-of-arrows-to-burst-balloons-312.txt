class Solution {

    public int findMinArrowShots(int[][] points) {
        int n = points.length;
        if (n <= 1) {
            // It is Base Case, But don\'t need to write it because below code handle all the input starting from 1, But by writing it at n <= 1 sorting don\'t take place. So it reduce the Runtime at n <=1
            return n;
        }
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        // sorting the array according to end element that is Xend
        // AtLeast single arrow will be required according to the constraints(1 <= points.length <= 10^5)
        int arrows = 1;
        int prevEnd = points[0][1];
        for (int i = 1; i < n; ++i) {
            if (prevEnd < points[i][0]) {
                // if previous Xend is less current Xstart than the points are non overlapping(else points are overlapping) And don\'t need to check with the current Xend (that is (curr Xend) >= (prev Xend)) because array is sorted according to Xend
                arrows++;
                // updating the previous End
                prevEnd = points[i][1];
            }
        }
        return arrows;
    }
}
