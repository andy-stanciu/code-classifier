class Solution {

    public void gameOfLife(int[][] board) {
        int[][] newBoard;
        newBoard = new int[board.length][board[0].length];
        // assigning values for new array, for next stage
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[i].length; ++j) {
                board[i][j] = getLife(board, i, j);
            }
        }
        // copying newBoard into existing board
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[i].length; ++j) {
                if (board[i][j] == -1) {
                    board[i][j] = 1;
                } else if (board[i][j] == 2) {
                    board[i][j] = 0;
                }
            }
        }
    }

    // decides the life of the new board based on the current board (parameter)
    private int getLife(int[][] board, int i, int j) {
        int liveNeighbours;
        // return a different value if the conditions are met, otherwise return the same value
        if (board[i][j] <= 0 && getLiveCount(board, i, j) == 3) {
            // went from dead to alive (treat momentarily as dead)
            return -1;
        } else if (board[i][j] >= 1) {
            if (getLiveCount(board, i, j) < 2 || getLiveCount(board, i, j) > 3) {
                // went from alive to dead (treat momentarily as alive)
                return 2;
            }
        }
        return board[i][j];
    }

    // checks the bounds of the board and counts the number of live elements around the provided element
    private int getLiveCount(int[][] board, int i, int j) {
        int x, y, count, checked;
        y = i - 1;
        x = j - 1;
        count = 0;
        checked = 0;
        // circle around each board element, checking all 8 squares
        while (checked < 8) {
            if (withinBounds(board[i].length, board.length, y, x) && board[y][x] >= 1) {
                ++count;
            }
            ++checked;
            // adjust position of element currently checked
            if (x <= j && y < i) {
                ++x;
            } else if (x > j && y <= i) {
                ++y;
            } else if (x >= j && y > i) {
                --x;
            } else {
                --y;
            }
        }
        return count;
    }

    // helper to check if the current element is within the bounds of the array
    private boolean withinBounds(int xLength, int yLength, int i, int j) {
        return i >= 0 && i < yLength && j < xLength && j >= 0;
    }
}
// Cases
// live cell, under 2 live neighbours dies (set to 0)
// live cell, more then 3 live neighbours dies (set to 0)
// dead cell, exactly 3 live neighbours (set to 1)
