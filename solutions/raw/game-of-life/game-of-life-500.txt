// Greedy Solution
// Time: O(MN)
// Space: O(1) no extra space
class Solution {

    private static final int DEAD = 0;

    private static final int LIVE = 1;

    private static final int LIVE_TO_DEAD = 2;

    private static final int DEAD_TO_LIVE = 3;

    private static final int[][] NEIGHBORS = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };

    public void gameOfLife(int[][] board) {
        // ask whetehr board could be null;
        if (board.length == 0 || board[0].length == 0)
            return;
        final int M = board.length, N = board[0].length;
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                // count live neighbors
                int count = 0;
                for (int[] neighbor : NEIGHBORS) {
                    int i = neighbor[0] + x;
                    int j = neighbor[1] + y;
                    if (outOfBound(board, i, j))
                        continue;
                    if (board[i][j] == LIVE || board[i][j] == LIVE_TO_DEAD)
                        count++;
                }
                if ((count < 2 || count > 3) && board[x][y] == LIVE) {
                    board[x][y] = LIVE_TO_DEAD;
                }
                if (count == 3 && board[x][y] == DEAD) {
                    board[x][y] = DEAD_TO_LIVE;
                }
            }
        }
        for (int x = 0; x < M; x++) {
            for (int y = 0; y < N; y++) {
                if (board[x][y] == LIVE_TO_DEAD)
                    board[x][y] = DEAD;
                else if (board[x][y] == DEAD_TO_LIVE)
                    board[x][y] = LIVE;
            }
        }
    }

    private boolean outOfBound(int[][] board, int i, int j) {
        return i < 0 || j < 0 || i >= board.length || j >= board[0].length;
    }
}
