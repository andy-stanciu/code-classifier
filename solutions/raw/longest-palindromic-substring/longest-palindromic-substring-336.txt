class Solution {

    // greedy solution
    public String longestPalindrome(String s) {
        int n = s.length();
        // to keep the longest distance j and k
        int[] pair = new int[2];
        for (int i = 0; i < n; i++) {
            // Assume that the length of longest palidrome is of odd length
            // in this case use two pointers j, k and expand them from each position of string
            // start from j=0,k=0 then j=1,k=1 then j=2,k=2 and so on
            int[] pair1 = findLongestPalindrome(i, i, s, n);
            // Assume that the length of longest palidrome is of even length
            // in this case use two pointers j, k and expand them from each adjacent position of string
            // start from j=0,k=1 then j=1,k=2 then j=2,k=3 and so on
            int[] pair2 = findLongestPalindrome(i, i + 1, s, n);
            // get max among pair, pair1 and pair3
            if ((pair1[1] - pair1[0]) > (pair2[1] - pair2[0]) && (pair1[1] - pair1[0]) > (pair[1] - pair[0])) {
                // keep the bigger length
                pair[0] = pair1[0];
                pair[1] = pair1[1];
            } else if ((pair2[1] - pair2[0]) > (pair1[1] - pair1[0]) && (pair2[1] - pair2[0]) > (pair[1] - pair[0])) {
                pair[0] = pair2[0];
                pair[1] = pair2[1];
            }
        }
        return s.substring(pair[0], pair[1] + 1);
    }

    private int[] findLongestPalindrome(int j, int k, String s, int n) {
        while (j >= 0 && k < n && s.charAt(j) == s.charAt(k)) {
            j--;
            k++;
        }
        return new int[] { j + 1, k - 1 };
    }
}
