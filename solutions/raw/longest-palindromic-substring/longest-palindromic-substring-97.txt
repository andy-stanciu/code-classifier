class Solution {

    /**
     *          **************** Approach - 1 ********************
     *
     *   In this approach we will try to solve it using Dynamic Programming
     */
    /**
     *     We can take an 2D boolean array, where we will be storing from position -> to position whether the string is palindrome or not
     *     Both row and column wise we will be keeping the same String like below. But Column wise we want to denote it as END position
     *     and Row wise Start position
     *
     *     Any position will denote the (row, col) starting from position (row number) till position (col number)
     *     Like position (1,3) denotes from position 1 to position 3 whether the string is palindrome or not
     *
     *     So we won\'t be considering the position below the diagonal line, because for those position
     *     row number > col number meaning start is > end meaning those are not valid position.
     *
     *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.
     *             Because start and end position is same. So, it consists of one character only.
     *
     *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.
     *             Because there are only two characters are there.
     *
     *    Case-3 : For all rest of the position check the start and end position if true check for middle part of the string.
     *             like for position (1,3) check whether the start and end is same or not, meaning character at position 1
     *             and position 3 is same or not.
     *             If same, check the middle part of the string i.e. check for (start+1) till (End -1) position.
     *             in this case we have to check whether the middle part of the String i.e. (2,2) is
     *             palindrome or not.
     *
     *             To check that middle portions result we can check the left diagonal value i.e. for (i,j) check for (i+1 , j -1)
     *             i.e. for pos (1,3) check the position (2,2)
     *
     *                          END --->
     *               0        1       2         3         4
     *               b        a       b         a         d
     *     -------------------------------------------------------
     *       0  b   T(b)   F(ab)   T(bab)   F(baba)    F(babad)
     *
     *   S   1  a          T(a)     F(ab)   T(aba)     F(abad)
     *   T
     *   A   2  b                   T(b)    F(ba)      F(bad)
     *   R
     *   T   3  a                           T(a)       F(ad)
     *
     *       4  d                                      T(d)
     */
    public String longestPalindrome1(String str) {
        boolean[][] dp = new boolean[str.length()][str.length()];
        int start = 0, end = 0;
        /**
         * The loop should be Diagonal wise Starting with gap = 0 till string length
         * First loop it should cover [(0,0), (1,1), (2,2), (3,3), (4,4)]
         * Second Loop - (0,1), (1,2), (2,3) & (3,4)
         *
         * Like this diagonally it should travel and solve the problem.
         */
        for (int gap = 0; gap < str.length(); gap++) {
            for (int i = 0, j = gap; j < dp[0].length; i++, j++) {
                /**
                 *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.
                 *             Because start and end position is same. So, it consists of one character only.
                 */
                if (gap == 0) {
                    dp[i][j] = true;
                    continue;
                }
                /**
                 *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.
                 *             Because there are only two characters are there.
                 */
                if (gap == 1 && str.charAt(i) == str.charAt(j)) {
                    dp[i][j] = true;
                } else /**
                 *  Case-3 : For all rest of the position check the start and end position
                 *           If true check for middle part of the string i.e. check for (start+1) till (End -1) position.
                 *           Which can be obtained from left diagonal value i.e. for (i,j) check for (i+1 , j -1)
                 */
                if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] == true) {
                    dp[i][j] = true;
                }
                /**
                 * Keeping track of the Start end End position of the Palindromic String.
                 * As Gap is increasing we are not doing any comparison with the previous range.
                 * With increasing of the Gap value if the substring is palindrome then it will be
                 * the bigger substring.
                 */
                if (dp[i][j]) {
                    start = i;
                    end = j;
                }
            }
        }
        return str.substring(start, end + 1);
    }

    /**
     *                  *****************   Approach - 2   ********************
     *
     *  The intention is by taking each position as its probable middle position of the substring, we will try to expand the
     *  search by both the direction.
     *  Like for any position we will try to expand the the value in the both side and validate whether its a palindrome or not.
     *     Expand Start   <--   (position)   --> Expand End
     */
    int start, end, maxLength = Integer.MIN_VALUE;

    public String longestPalindrome(String inputStr) {
        /**
         * Base case :
         * If the string is Empty or single character string then return it.
         */
        if (inputStr.length() < 2) {
            return inputStr;
        }
        for (int index = 0; index < inputStr.length() - 1; index++) {
            /**
             * we are calling the same function twice because we are not sure
             * the substring size will be of even or odd.
             *
             * If odd then we will be getting a middle point like for the String
             * "abcdcba" middle will be 3 i.e. character \'d\'
             *
             * but for the even number the middle will be 2 position like for
             * the String "xyzzyx" middle will be 2 and 3 position
             */
            expandSearch(inputStr, index, index);
            expandSearch(inputStr, index, index + 1);
        }
        return inputStr.substring(start, end);
    }

    private void expandSearch(String inputStr, int startPosition, int endPosition) {
        while (startPosition >= 0 && endPosition < inputStr.length() && inputStr.charAt(startPosition) == inputStr.charAt(endPosition)) {
            startPosition--;
            endPosition++;
        }
        int substringLength = endPosition - startPosition - 1;
        /**
         * Keeping track of the max SubString length and corresponding start and end
         */
        if (substringLength > maxLength) {
            this.start = startPosition + 1;
            end = endPosition;
            this.maxLength = substringLength;
        }
    }
}
