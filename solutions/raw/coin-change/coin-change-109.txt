class Solution {

    public int coinChange(int[] coins, int amount) {
        if (amount < 1)
            return 0;
        //below array will have index as amount and value as minCoins for that amount
        //if value is 0, it means we can\'t reach that amount with available coins
        int[] dp = new int[amount + 1];
        //in below loop, We evaluate minCoins for EACH amount/index upto the given amount/index
        for (int currAmt = 1; currAmt <= amount; currAmt++) {
            //in below loop, we find best coin for current amount/index
            for (int coin : coins) {
                //diff tells us the prev-amount before adding this coin
                int diff = currAmt - coin;
                if (//coin is bigger than curr amount, skip
                diff < 0)
                    continue;
                if (//coin is EQUAL to curr amount, BEST choice
                diff == 0)
                    //only current coin was needed to reach this amount
                    dp[currAmt] = 1;
                else if (dp[diff] > 0) {
                    //A prev-amount with minCoins exists (DP!), we can add this coin
                    //adding the coin
                    int newAmtOfCoins = dp[diff] + 1;
                    if (//we already have previous minCoins at this amount/index, find new min
                    dp[currAmt] > 0)
                        dp[currAmt] = Math.min(newAmtOfCoins, dp[currAmt]);
                    else
                        //no previous minCoins, this coin is the best option so far
                        dp[currAmt] = newAmtOfCoins;
                }
            }
        }
        //last index of array is the answer, if it\'s 0 then there\'s no answer
        return dp[amount] == 0 ? -1 : dp[amount];
    }
}
