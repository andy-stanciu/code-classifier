class Solution {

    public int coinChange(int[] coins, int amount) {
        //comparing to knapSack(unbounded)
        int[][] dp = new int[coins.length + 1][amount + 1];
        //value at dp[i][j] shows the min number of coins required to make up the sum \'j\' using coin denomination upto \'i\';
        for (int i = 1; i < dp[0].length; i++) {
            dp[0][i] = -1;
        }
        //intitialising -1 as we cannot make up the value without any coins
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                //bottom up approach
                //curr val of the coin
                int val = coins[i - 1];
                if (val <= j) {
                    // we can either include or not
                    if (dp[i][j - val] == -1) {
                        // there is no solution for the smaller problem if we are trying to include the current coin
                        if (dp[i - 1][j] != -1) {
                            //but there is a solution for the smaller problem if we ignore the current coin
                            dp[i][j] = dp[i - 1][j];
                        } else {
                            //if none of them works we mark it as not possible
                            dp[i][j] = -1;
                        }
                    } else {
                        //if the solution for smaller problem exists
                        //coins req if we include the current coin
                        int include = 1 + dp[i][j - val];
                        //without the current coin
                        int exclude = dp[i - 1][j];
                        if (exclude > 0) {
                            // if valid answer for \'exclude\' exists
                            dp[i][j] = Math.min(include, exclude);
                        } else {
                            dp[i][j] = include;
                        }
                    }
                } else {
                    //if the current val is greater than target - exclude only
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        // answer for the main problem exists in last cell
        return dp[coins.length][amount];
    }
}
