class Solution {

    public int coinChange(int[] coins, int A) {
        int result = solve(0, A, coins, new Integer[coins.length][A + 1]);
        if (result == Integer.MAX_VALUE) {
            return -1;
        }
        return result;
    }

    private int solve(int idx, int A, int[] coins, Integer[][] dp) {
        if (A == 0) {
            // No coins needed
            return 0;
        }
        if (idx == coins.length || A < 0) {
            // Invalid case
            return Integer.MAX_VALUE;
        }
        if (dp[idx][A] != null) {
            // Return cached result
            return dp[idx][A];
        }
        // Option 1: Include the coin
        int sp1 = solve(idx, A - coins[idx], coins, dp);
        if (sp1 != Integer.MAX_VALUE) {
            // Count this coin
            sp1++;
        }
        // Option 2: Exclude the coin
        int sp2 = solve(idx + 1, A, coins, dp);
        //System.out.println(sp1+" "+sp2);
        // Store and return the minimum of including or excluding the coin
        dp[idx][A] = Math.min(sp1, sp2);
        return Math.min(sp1, sp2);
    }
}
