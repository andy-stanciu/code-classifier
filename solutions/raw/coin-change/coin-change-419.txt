class Solution {

    public int coinChange(int[] coins, int amount) {
        /*
        // sort coins and remove duplicate
        int count = 0;
        for (int i = 0; i < coins.length; i++){
            if (amount - coins[i] < 0) continue;
            count += amount/coins[i];
            if (count % coins[i] == 0) break;
        }
        return count;
        */
        // this question needs to make sure to make up that amount then choose the fewest.
        //dp[] find the first index of true???
        // dp[][] = dp[][amount - coins[i]] or dp[][amount]
        // dp[] = dp[] or dp[];
        Queue<Integer> q = new LinkedList<>();
        q.add(0);
        int cs = 0;
        boolean[] vstd = new boolean[amount + 1];
        while (!q.isEmpty()) {
            // n = 1
            int n = q.size();
            for (int i = 0; i < n; i++) {
                //sum = 0 (initial)
                int sum = q.poll();
                if (sum == amount)
                    return cs;
                if (sum > amount || vstd[sum]) {
                    //sum\u5927\u4E8Etarget or visited\uFF1F\uFF1Fvstd[0] = false (initial)
                    //to next coins???
                    continue;
                }
                // vstd[0] = true
                vstd[sum] = true;
                for (int coin : coins) {
                    //add coins to queue;
                    q.add(sum + coin);
                }
            }
            cs++;
        }
        return -1;
    }
}
