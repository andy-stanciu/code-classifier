class Solution {

    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int n = coins.length;
        if (amount == 0)
            return 0;
        // int[][]dp=new int[n][amount+1];
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<=amount;j++){
        //         dp[i][j]=-1;
        //     }
        // }
        int[] prev = new int[amount + 1];
        int[] cur = new int[amount + 1];
        // int ans=findRecur(n-1,coins,amount,dp);
        // return ans==(int)1e9?-1:ans;
        //Tabulation
        // for(int i=0;i<=amount;i++){
        //     if(i%coins[0]==0) dp[0][i]=i/coins[0];
        //     else dp[0][i]=(int)1e9;
        // }
        for (int i = 0; i <= amount; i++) {
            if (i % coins[0] == 0)
                prev[i] = i / coins[0];
            else
                prev[i] = (int) 1e9;
        }
        for (int idx = 1; idx < n; idx++) {
            for (int sum = 0; sum <= amount; sum++) {
                int notPick = prev[sum];
                int pick = Integer.MAX_VALUE;
                if (sum >= coins[idx])
                    pick = 1 + cur[sum - coins[idx]];
                cur[sum] = Math.min(notPick, pick);
            }
            prev = cur;
        }
        return prev[amount] == (int) 1e9 ? -1 : prev[amount];
    }

    //Memoization
    public int findRecur(int idx, int[] coins, int amount, int[][] dp) {
        if (idx == 0) {
            if (amount % coins[idx] == 0)
                return amount / coins[idx];
            else if (amount == coins[idx])
                return 1;
            else
                return (int) 1e9;
        }
        if (dp[idx][amount] != -1)
            return dp[idx][amount];
        int notPick = findRecur(idx - 1, coins, amount, dp);
        int pick = Integer.MAX_VALUE;
        if (amount >= coins[idx])
            pick = 1 + findRecur(idx, coins, amount - coins[idx], dp);
        return dp[idx][amount] = Math.min(notPick, pick);
    }
}
