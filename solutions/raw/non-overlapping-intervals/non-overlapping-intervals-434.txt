class Solution {

    public int eraseOverlapIntervals(int[][] intervals) {
        // If there are 0 or 1 intervals, there can\'t be any overlaps
        if (intervals.length <= 1)
            return 0;
        // Sort intervals based on their starting points
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        // Initialize the previous interval as the first interval in the sorted list
        int[] prevInterval = intervals[0];
        int intervalCount = 0;
        // Loop through the intervals starting from the second one
        for (int i = 1; i < intervals.length; i++) {
            int[] currInterval = intervals[i];
            // If there is an overlap between the current interval and the previous one
            if (prevInterval[1] > currInterval[0]) {
                // Increment the interval count because we need to remove one of the intervals
                intervalCount++;
                // Choose the interval that ends earlier
                prevInterval[0] = Math.min(prevInterval[0], currInterval[0]);
                prevInterval[1] = Math.min(prevInterval[1], currInterval[1]);
            } else {
                // If there is no overlap, update the previous interval to be the current one
                prevInterval = currInterval;
            }
        }
        // Return the number of intervals that need to be removed to remove all overlaps
        return intervalCount;
    }
}
