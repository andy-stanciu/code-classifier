class Solution {

    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a1, a2) -> {
            if (a1[0] == a2[0])
                return a1[1] - a2[1];
            return a1[0] - a2[0];
        });
        int[] memo = new int[intervals.length];
        Arrays.fill(memo, -1);
        return slv(0, -1, intervals, memo);
    }

    private int slv(int n, int prev, int[][] intervals, int[] memo) {
        if (n >= intervals.length || n == -1)
            return 0;
        if (memo[n] != -1)
            return memo[n];
        int min = Integer.MAX_VALUE;
        if (prev == -1 || (intervals[n][0] >= intervals[prev][1] && intervals[n][1] >= intervals[prev][1])) {
            int index = binarySearch(intervals, n + 1, intervals.length - 1, intervals[n][1]);
            if (index == -1)
                min = Math.min(min, (intervals.length - 1 - n) + slv(index, n, intervals, memo));
            else
                min = Math.min(min, (index - n - 1) + slv(index, n, intervals, memo));
        }
        return memo[n] = Math.min(min, 1 + slv(n + 1, prev, intervals, memo));
    }

    int binarySearch(int[][] intervals, int l, int h, int end) {
        int ans = -1;
        while (l <= h) {
            int mid = (l + h) / 2;
            if (intervals[mid][0] >= end) {
                h = mid - 1;
                ans = mid;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }
}
