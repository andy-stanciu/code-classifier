class Solution {

    public int eraseOverlapIntervals(int[][] intervals) {
        // return solveWithGreedy(intervals);
        return solveWithGreedyRadixSort(intervals);
    }

    public int solveWithGreedyRadixSort(int[][] intervals) {
        if (intervals.length < 5000) {
            return solveWithGreedy(intervals);
        }
        // sort by endtime
        var starttimes = radixSort(intervals);
        // find first
        int i = 0;
        int prevend = -1;
        for (; i < starttimes.length; i++) {
            if (starttimes[i] != -1) {
                prevend = i;
                break;
            }
        }
        if (prevend == -1) {
            throw new RuntimeException("something wrong");
        }
        // find max possible without overlap
        int total = 1;
        i = i + 1;
        for (; i < starttimes.length; i++) {
            var currend = i;
            var currstart = starttimes[i];
            if (currstart == -1) {
                // non real
                continue;
            }
            // see if we don\'t overlap
            if (prevend <= currstart) {
                total++;
                prevend = currend;
            }
        }
        return intervals.length - total;
    }

    int[] radixSort(int[][] arr) {
        int SHIFT = 50_000;
        int[] starttimes = new int[100_002];
        // fill with empty marker
        Arrays.fill(starttimes, -1);
        for (var ar : arr) {
            int end = ar[1] + SHIFT;
            starttimes[end] = Math.max(starttimes[end], ar[0] + SHIFT);
        }
        return starttimes;
    }

    public int solveWithGreedy(int[][] intervals) {
        // sort by endtime
        Arrays.sort(intervals, new Comparator<int[]>() {

            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[1] < o2[1]) {
                    return -1;
                } else if (o1[1] > o2[1]) {
                    return 1;
                }
                return Integer.compare(o1[0], o2[0]);
            }
        });
        // find max possible without overlap
        int total = 1;
        var prev = intervals[0];
        for (int i = 1; i < intervals.length; i++) {
            var curr = intervals[i];
            // see if we don\'t overlap
            if (prev[1] <= curr[0]) {
                total++;
                prev = curr;
            }
        }
        return intervals.length - total;
    }
}
