class Solution {

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> comb = new ArrayList<>();
        backtrack(1, comb, res, n, k);
        return res;
    }

    private void backtrack(int start, List<Integer> comb, List<List<Integer>> res, int n, int k) {
        if (comb.size() == k) {
            //to check if the combination is valid
            //append a copy of the current comb list to the res list
            res.add(new ArrayList<>(comb));
            return;
        }
        for (int num = start; num <= n; num++) {
            //recursion
            comb.add(num);
            //(num+1) is used to ensures that each number can only be used once in each combination
            backtrack(num + 1, comb, res, n, k);
            comb.remove(comb.size() - 1);
        }
    }
}
//SC:O(k), TC:O(n*k)
/* new ArrayList<>(list) will make a copy of list, which will make sure the elements be stored into res.
Otherwise, after list.remove(list.size()-1), the elements in res will be removed.
The code uses a recursive backtracking approach to generate all the combinations efficiently. It explores all possible combinations, avoiding duplicates and forming valid combinations of size k. The result res will contain all such combinations at the end.
*/
