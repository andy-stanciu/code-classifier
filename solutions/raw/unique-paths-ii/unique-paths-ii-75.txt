class Solution {

    // //recursion
    int mod = 2 * (int) Math.pow(10, 9);

    // public int uniquePathsWithObstaclesHelper(int[][] obstacleGrid, int i ,int j) {
    //     if(i == 0 && j == 0) return 1;
    //     if(i < 0 || j < 0) return 0;
    //     if((i >= 0 && j >= 0) && obstacleGrid[i][j] == 1) return 0;
    //     int up = uniquePathsWithObstaclesHelper( obstacleGrid,  i- 1 , j);
    //     int left = uniquePathsWithObstaclesHelper( obstacleGrid,  i , j - 1);
    //     return (up + left) % mod;
    // }
    //  public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    //      int rows = obstacleGrid.length;
    //      int cols = obstacleGrid[0].length;
    //     return uniquePathsWithObstaclesHelper( obstacleGrid,  rows - 1 , cols -1);
    // }
    //memoization o(m*n)  sc- o(N)+ O(n*m)
    //    public int uniquePathsWithObstaclesH(int[][] obstacleGrid , int i , int j,int[][] dp) {
    //      if(i ==0 && j ==0) return 1;
    //      if(i < 0 || j < 0) return 0;
    //      if(i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) return 0;
    //      if(dp[i][j] != -1) return dp[i][j];
    //      int up =  uniquePathsWithObstaclesH(obstacleGrid , i -1 , j, dp);
    //      int left =  uniquePathsWithObstaclesH(obstacleGrid , i  , j - 1, dp);
    //      return dp[i][j] = up + left;
    //    }
    //     public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    //          int rows = obstacleGrid.length;
    //          int cols = obstacleGrid[0].length;
    //          int[][] dp = new int[rows][cols];
    //          for(int[] row : dp){
    //             Arrays.fill(row , -1);
    //          }
    //          return uniquePathsWithObstaclesH(obstacleGrid , rows - 1 , cols - 1, dp);
    //     }
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // tabulation with space optimisation  tc =O(m*n) sc =O(n)
        int rows = obstacleGrid.length;
        int cols = obstacleGrid[0].length;
        int[] prev = new int[cols];
        Arrays.fill(prev, -1);
        for (int i = 0; i < rows; i++) {
            int[] curr = new int[cols];
            for (int j = 0; j < cols; j++) {
                if (i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) {
                    curr[j] = 0;
                } else if (i == 0 && j == 0) {
                    curr[j] = 1;
                } else {
                    int up = 0;
                    int left = 0;
                    if (i > 0)
                        up = prev[j];
                    if (j > 0)
                        left = curr[j - 1];
                    curr[j] = up + left;
                }
            }
            prev = curr;
        }
        return prev[cols - 1] % mod;
    }
}
