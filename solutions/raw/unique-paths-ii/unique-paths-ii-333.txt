class Solution {

    int endRow, endCol;

    int[][] dp;

    int[][] grid;

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        endRow = obstacleGrid.length - 1;
        endCol = obstacleGrid[0].length - 1;
        // Minor optimization
        if (obstacleGrid[0][0] == 1 || obstacleGrid[endRow][endCol] == 1)
            return 0;
        grid = obstacleGrid;
        dp = new int[endRow + 1][endCol + 1];
        for (int[] dpRow : dp) Arrays.fill(dpRow, -1);
        return uniquePathsWithObstacles(0, 0);
    }

    private int uniquePathsWithObstacles(int startRow, int startCol) {
        if (startRow > endRow || startCol > endCol || grid[startRow][startCol] == 1)
            return 0;
        if (dp[startRow][startCol] != -1)
            return dp[startRow][startCol];
        if (startRow == endRow && startCol == endCol)
            return 1;
        return dp[startRow][startCol] = uniquePathsWithObstacles(startRow + 1, startCol) + uniquePathsWithObstacles(startRow, startCol + 1);
    }
}
