class Solution {

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length;
        int m = obstacleGrid[0].length;
        int[][] memo = new int[n][m];
        // Initialize memo array with -1
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return gridWays(obstacleGrid, memo, n - 1, m - 1);
    }

    public int gridWays(int[][] obstacleGrid, int[][] memo, int n, int m) {
        // If out of bounds or the cell is an obstacle
        if (n < 0 || m < 0 || obstacleGrid[n][m] == 1) {
            return 0;
        }
        // If at the start cell
        if (n == 0 && m == 0) {
            return 1;
        }
        // Return the result if already computed
        if (memo[n][m] != -1) {
            return memo[n][m];
        }
        // Calculate the number of unique paths
        int fromTop = gridWays(obstacleGrid, memo, n - 1, m);
        int fromLeft = gridWays(obstacleGrid, memo, n, m - 1);
        // Memoize the result
        memo[n][m] = fromTop + fromLeft;
        return memo[n][m];
    }
}
