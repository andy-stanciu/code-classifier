class Solution {

    /*
        dynamic programming:
        let UniquePath(i, j) be the number of unique paths to reach (i, j) from (0, 0) by only moving down or right

        to reach (i, j), we either go down from (i-1, j) or go right from (i, j-1)
        UniquePath(i, j) =
                     - case 1: UniquePath(i-1, j) + UniquePath(i, j-1), if obstacleGrid[i][j] == 0
                     - case 2: 0                                      , if obstacleGrid[i][j] == 1

        base cases:
        UniquePath(0, x) =
                    - case 1: UniquePath(0, x-1), if obstacleGrid[0][x] == 0
                    - case 2: 0, otherwise

        UniquePath(x, 0) =
                    - case 1: UniquePath(x-1, 0), if obstacleGrid[x][0] == 0
                    - case 2: 0, otherwise

        UniquePath(0, 0) = 1 if obstacleGrid[0][0] == 0, 0 otherwise
    */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // edge cases
        int m = obstacleGrid.length;
        if (m == 0) {
            return 1;
        }
        int n = obstacleGrid[0].length;
        if (n == 0) {
            return 1;
        }
        int[][] uniquePath = new int[m][n];
        // base cases
        uniquePath[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 1; i < m; i++) {
            uniquePath[i][0] = obstacleGrid[i][0] == 0 ? uniquePath[i - 1][0] : 0;
        }
        for (int j = 1; j < n; j++) {
            uniquePath[0][j] = obstacleGrid[0][j] == 0 ? uniquePath[0][j - 1] : 0;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 0) {
                    // case 1
                    uniquePath[i][j] = uniquePath[i - 1][j] + uniquePath[i][j - 1];
                } else {
                    // case 2
                    uniquePath[i][j] = 0;
                }
            }
        }
        return uniquePath[m - 1][n - 1];
    }
}
