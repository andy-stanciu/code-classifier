public class TreeNode {

    int val;

    // Add variable to store the number of descendant nodes including itself.
    int descendant;

    TreeNode left;

    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
        this.descendant = 1;
    }

    TreeNode(int val, int descendant, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
        this.descendant = descendant;
    }
}

class Solution {

    /**
     * Time O(n), Tree traversal
     * Space O(h)
     */
    private void rebuildTree(TreeNode root) {
        if (root == null)
            return;
        if (root.left != null) {
            rebuildTree(root.left);
            root.descendant += root.left.descendant;
        }
        if (root.right != null) {
            rebuildTree(root.right);
            root.descendant += root.right.descendant;
        }
    }

    public int kthSmallest(TreeNode root, int k) {
        // This rebuild function should update every time when BST is modified.
        rebuildTree(root);
        /**
         * So, we have more efficient time to get the answer.
         * Time O(log n)
         * Space O(h)
         */
        return dfs(root, k);
    }

    /**
     * Time O(log n)
     *   - Without traverse
     * Space O(h)
     *   - Each element costs constant space O(1).
     *     And the size of the stack is exactly the depth of DFS.
     *     So in the worst case, it costs O(h) to maintain the system stack,
     *     where h is the maximum depth of DFS.
     */
    public int dfs(TreeNode node, int k) {
        if (node.left != null) {
            if (k <= node.left.descendant) {
                return dfs(node.left, k);
            } else if (k > node.left.descendant + 1) {
                return dfs(node.right, k - node.left.descendant - 1);
            }
            return node.val;
        } else {
            if (k == 1)
                return node.val;
            return dfs(node.right, k - 1);
        }
    }
}
