class Solution {

    public //BST inorder is ascendingly sorted
    //BST inorder is ascendingly sorted
    //BST inorder is ascendingly sorted
    //BST inorder is ascendingly sorted
    //BST inorder is ascendingly sorted
    void inorderSolve(TreeNode root, int k, int[] result) {
        if (//Base Condition
        root == null)
            return;
        //Recursing the Left side of the tree
        inorderSolve(root.left, k, result);
        //increamenting the of index
        result[0] = result[0] + 1;
        if (result[0] == k) {
            //when the required index is found
            //Storing the value with the value present at kth index & -1 is for index out of bound
            result[1] = root.val;
            return;
        }
        //Recursing the Right side of the tree
        inorderSolve(root.right, k, result);
        //returning to the callinng function
        return;
    }

    public int kthSmallest(TreeNode root, int k) {
        int[] result = { 0, -1 };
        //calling the inorder function to get the samllest kth element
        inorderSolve(root, k, result);
        //if the index is out of bound then -1 is returned, else the value is returned
        return result[1];
    }
}
