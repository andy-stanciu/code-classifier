class Solution {

    ArrayList<Integer> ans = new ArrayList<>();

    int c;

    public int kthSmallest(TreeNode root, int k) {
        c = k;
        if (root == null)
            return 0;
        // In-Order-Traversal
        // Left- Root- Right: Essentially returns value in ascending order (KEY POINT)
        inOrder(root);
        return ans.get(k - 1);
    }

    void inOrder(TreeNode root) {
        // Base Case: If size of arraylist exceeds K we do not need to add any elements
        if (root == null || ans.size() > c)
            return;
        // If the node exists, we move to its left
        inOrder(root.left);
        // While coming back, add so that inorder
        if (ans.size() <= c)
            ans.add(root.val);
        // For the current node, all left nodes are accessed, now to the right
        inOrder(root.right);
    }
}
/*
Generally:
Pre-order: Used to create a copy of a tree. For example, if you want to create a replica of a tree, put the nodes in an array with a pre-order traversal. Then perform an Insert operation on a new tree for each value in the array. You will end up with a copy of your original tree.

In-order: : Used to get the values of the nodes in non-decreasing order in a BST.

Post-order: : Used to delete a tree from leaf to root

Source: StackOverflow (Where to use PreOrder, InOrder and PostOrder traversals )
*/
