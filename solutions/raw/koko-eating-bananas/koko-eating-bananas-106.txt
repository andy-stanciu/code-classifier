class Solution {

    // k has to be bounded from 1 to max pile
    // so we can just binary search in that range
    // and find the lowest value that satisifies
    // so if the k is satisfactory then we check left
    // if the k isn\'t satisfactory then we check right
    public int minEatingSpeed(int[] piles, int h) {
        int maxPile = -1;
        for (int i = 0; i < piles.length; i++) {
            maxPile = Math.max(maxPile, piles[i]);
        }
        int low = 1;
        int high = maxPile;
        int k = -1;
        int result = 1;
        while (low <= high) {
            System.out.println(low);
            System.out.println(high);
            k = (low + high) / 2;
            if (checkPos(piles, h, k)) {
                high = k - 1;
            } else {
                low = k + 1;
                result = k + 1;
            }
        }
        return result;
    }

    public boolean checkPos(int[] piles, int h, int k) {
        int count = 0;
        for (int i = 0; i < piles.length; i++) {
            if (piles[i] % k == 0) {
                count += Math.floor(piles[i] / k);
            } else {
                count += Math.floor(piles[i] / k);
                count++;
            }
        }
        if (count > h) {
            return false;
        } else {
            return true;
        }
    }
}
