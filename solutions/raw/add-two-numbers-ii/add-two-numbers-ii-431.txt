/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //Reverse both the Linked list
        l1 = rev(l1);
        l2 = rev(l2);
        //initiate head node
        ListNode head = new ListNode(-1);
        ListNode curr = head;
        //consider carry as 0
        int carry = 0;
        //until there are nodes in both linked list
        while (l1 != null && l2 != null) {
            //compute sum
            int val = l1.val + l2.val + carry;
            if (val >= 10) {
                //if val >= 10 set carry as 1 and make val=val-10
                carry = 1;
                val -= 10;
            } else {
                carry = 0;
            }
            //change val of current node
            curr.val = val;
            //add new node
            curr.next = new ListNode(-1);
            //go to next nodes
            curr = curr.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        //Traverse any nodes left in l1 linked list same way
        while (l1 != null) {
            int val = l1.val + carry;
            if (val >= 10) {
                carry = 1;
                val -= 10;
            } else {
                carry = 0;
            }
            curr.val = val;
            curr.next = new ListNode(-1);
            curr = curr.next;
            l1 = l1.next;
        }
        //Traverse any nodes left in l2 linked list same way
        while (l2 != null) {
            int val = l2.val + carry;
            if (val >= 10) {
                carry = 1;
                val -= 10;
            } else {
                carry = 0;
            }
            curr.val = val;
            curr.next = new ListNode(-1);
            curr = curr.next;
            l2 = l2.next;
        }
        //At the end check if carry is 1
        if (carry == 1) {
            //if carry is there add a new node with val=1
            curr.val = 1;
            curr.next = new ListNode(-1);
            curr = curr.next;
        }
        //reverse our ans list
        //return the next node as the current node is -1
        return rev(head).next;
    }

    //Reversing Function
    public ListNode rev(ListNode l) {
        //maintains prev list which is reversed
        ListNode prev = null;
        while (l != null) {
            ListNode next = l.next;
            //adds prev list to currents next
            l.next = prev;
            //prev as curr node
            prev = l;
            //go to next node until null
            l = next;
        }
        return prev;
    }
}
