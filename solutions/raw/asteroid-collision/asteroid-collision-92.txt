class Solution {

    public int[] asteroidCollision(int[] asteroids) {
        ArrayList<Integer> al = new ArrayList<>();
        Stack<Integer> sk = new Stack<>();
        for (int i = 0; i < asteroids.length; i++) {
            if (asteroids[i] > 0)
                sk.push(i);
            else {
                if (!sk.isEmpty() && Math.abs(asteroids[i]) < asteroids[sk.peek()]) {
                    continue;
                } else if (!sk.isEmpty() && Math.abs(asteroids[i]) == asteroids[sk.peek()])
                    sk.pop();
                else {
                    while (!sk.isEmpty() && Math.abs(asteroids[i]) > asteroids[sk.peek()]) {
                        sk.pop();
                    }
                    // breasking from while loop will have three cases
                    // 1st edge case when negative asteroid dominates
                    if (sk.isEmpty())
                        al.add(asteroids[i]);
                    // 2nd edge case when asteroid and sk.peek()is equal
                    if (!sk.isEmpty() && Math.abs(asteroids[i]) == asteroids[sk.peek()])
                        sk.pop();
                    // 3rd possiblity is of course when negatives asteroid is dominated
                }
            }
        }
        int index = al.size();
        while (!sk.isEmpty()) al.add(index, asteroids[sk.pop()]);
        return al.stream().mapToInt(i -> i).toArray();
    }
}
