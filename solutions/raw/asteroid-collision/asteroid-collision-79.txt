class Solution {

    public enum ExplodeStatus {

        BOTH_EXPLODE, LEFT_EXPLODE, RIGHT_EXPLODE, NO_EXPLODE
    }

    public int[] asteroidCollision(int[] asteroids) {
        if (asteroids.length <= 1) {
            return asteroids;
        }
        final Stack<Integer> stack = new Stack<>();
        stack.push(asteroids[0]);
        for (int i = 1; i < asteroids.length; ) {
            if (stack.isEmpty()) {
                stack.push(asteroids[i]);
                i++;
                continue;
            }
            final ExplodeStatus status = findExplode(stack.peek(), asteroids[i]);
            switch(status) {
                case BOTH_EXPLODE:
                    stack.pop();
                    i++;
                    break;
                case LEFT_EXPLODE:
                    stack.pop();
                    break;
                case RIGHT_EXPLODE:
                    i++;
                    break;
                case NO_EXPLODE:
                    stack.push(asteroids[i]);
                    i++;
                    break;
            }
        }
        return stack.stream().mapToInt(Integer::intValue).toArray();
    }

    private boolean isPos(int value) {
        return value > 0;
    }

    private ExplodeStatus findExplode(int a, int b) {
        if (isPos(a) && isPos(b)) {
            return ExplodeStatus.NO_EXPLODE;
        } else if (!isPos(a) && !isPos(b)) {
            return ExplodeStatus.NO_EXPLODE;
        } else if (!isPos(a) && isPos(b)) {
            return ExplodeStatus.NO_EXPLODE;
        } else if (isPos(a) && !isPos(b)) {
            if (Math.abs(a) > Math.abs(b)) {
                // Collide situation
                return ExplodeStatus.RIGHT_EXPLODE;
            } else if (Math.abs(a) < Math.abs(b)) {
                return ExplodeStatus.LEFT_EXPLODE;
            } else {
                return ExplodeStatus.BOTH_EXPLODE;
            }
        }
        return ExplodeStatus.NO_EXPLODE;
    }
}
