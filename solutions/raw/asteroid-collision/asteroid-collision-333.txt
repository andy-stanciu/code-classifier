class Solution {

    public int[] asteroidCollision(int[] asteroids) {
        Stack<Pair<Integer, Integer>> st = new Stack<>();
        for (int i = 0; i < asteroids.length; i++) {
            if (st.isEmpty() || (st.peek().getKey() * asteroids[i] > 0) || (st.peek().getKey() < 0 && asteroids[i] > 0)) {
                //not collide
                st.add(new Pair<Integer, Integer>(asteroids[i], i));
            } else {
                //collide
                while (true) {
                    if (st.isEmpty()) {
                        //if stack is empty, add current stone to the stack
                        st.add(new Pair<>(asteroids[i], i));
                        break;
                    }
                    if (st.peek().getKey() > 0 && asteroids[i] < 0 && st.peek().getValue() < i) {
                        if (Math.abs(st.peek().getKey()) < Math.abs(asteroids[i])) {
                            //in-stack stone explodes
                            st.pop();
                        } else {
                            if (Math.abs(st.peek().getKey()) == Math.abs(asteroids[i])) {
                                st.pop();
                            }
                            break;
                        }
                    } else if (st.peek().getKey() * asteroids[i] > 0) {
                        //not collide
                        st.add(new Pair<>(asteroids[i], i));
                        break;
                    }
                }
            }
        }
        int[] res = new int[st.size()];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = st.pop().getKey();
        }
        return res;
    }
}
