class Solution {

    public void nextPermutation(int[] nums) {
        int k = 0, l = 0;
        // find the largest index nums[k] < nums[k+1] which satisfies this
        while (k < nums.length) {
            if (k + 1 < nums.length && nums[k] < nums[k + 1]) {
                l = k + 1;
            }
            k++;
        }
        //if no index found reverse the array from here
        if (l == 0) {
            int i = nums.length - 1;
            while (i >= (nums.length + 1) / 2) {
                swap(nums, nums.length - 1 - i, i);
                i--;
            }
            return;
        }
        //l-- because we were taking l = k + 1 above
        l--;
        //make k = l
        k = l;
        int replace = 0;
        //get the large index for which nums[k] is smaller
        while (l < nums.length) {
            if (l + 1 < nums.length && nums[k] < nums[l + 1]) {
                replace = l + 1;
            }
            l++;
        }
        //swap the values
        swap(nums, k, replace);
        replace = nums.length - 1;
        // node replace the values from k + 1
        while (k + 1 < replace) {
            swap(nums, k + 1, replace);
            replace--;
            k++;
        }
    }

    public void swap(int[] nums, int i, int j) {
        //Xor operator swaping without taking any extra variable
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
    }
}
