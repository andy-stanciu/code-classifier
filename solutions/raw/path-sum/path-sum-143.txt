/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private boolean helper(TreeNode root, int currSum, int targetSum) {
        // System.out.println(currSum + root.val);
        if (root.left == null && root.right == null) {
            /*

            this condition ensures if and only if both left and right subtrees are null 
            i.e the node is a leaf node then only we consider the sum other wise we dont 

            */
            if (currSum + root.val == targetSum)
                return true;
            return false;
        }
        /*

        if left subtree is null, then we need to go towards left subtree and viceversaa

        */
        if (root.left == null)
            return helper(root.right, currSum + root.val, targetSum);
        if (root.right == null)
            return helper(root.left, currSum + root.val, targetSum);
        /*

        if both left and right subtrees are not null , then we can search on both of those 
        sub trees for our target sum

        */
        return (helper(root.right, currSum + root.val, targetSum)) || (helper(root.left, currSum + root.val, targetSum));
    }

    public boolean hasPathSum(TreeNode root, int targetSum) {
        // if the root node is null, it will never meet the sum
        if (root == null)
            return false;
        // calling the function
        return helper(root, 0, targetSum);
    }
}
