class Solution {

    private boolean wordBreak(String str, int index, int existingWordStartingIndex, Set<String> wordSet, HashMap<Pair<Integer, Integer>, Boolean> dpMap) {
        if (index >= str.length()) {
            return wordSet.contains(str.substring(existingWordStartingIndex, str.length()));
        }
        Pair pair = new Pair(index, existingWordStartingIndex);
        if (dpMap.containsKey(pair))
            return dpMap.get(pair);
        String newWord = str.substring(existingWordStartingIndex, index + 1);
        boolean isWordBreakPossible = false;
        if (wordSet.contains(newWord)) {
            isWordBreakPossible = wordBreak(str, index + 1, existingWordStartingIndex, wordSet, dpMap) || wordBreak(str, index + 1, index + 1, wordSet, dpMap);
        } else {
            isWordBreakPossible = wordBreak(str, index + 1, existingWordStartingIndex, wordSet, dpMap);
        }
        dpMap.put(pair, isWordBreakPossible);
        return isWordBreakPossible;
    }

    public boolean wordBreak(String s, List<String> wordDict) {
        /**
         *            if current word is a match
         *                start new word
         *                continue with current word
         */
        Set<String> wordSet = new HashSet();
        for (String word : wordDict) {
            wordSet.add(word);
        }
        HashMap<Pair<Integer, Integer>, Boolean> dpMap = new HashMap();
        return wordBreak(s, 0, 0, wordSet, dpMap);
    }
}
