class Solution {

    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length;
        int n2 = nums2.length;
        int n = n1 + n2;
        /*
        For the mid point of an array:
        - if n is odd, length of first half is (n-1)/2
        - if n is even, length of the first half is n/2

        When n is even, the length of two partitions are equal,
        while for odd value of n, either the right or left will
        have one more element than the other.

        If we want the right partition to have more elements,
        the length of the left partition will be 
            (n-1)/2

        If we want the left partition to have more elements,
        the length of left partition will be: 
            (n-1)/2 + 1 
            = (n-1)/2 + 2/2 
            = (n - 1 + 2)/2
            = (n + 1)/2

        This will determine whether we are choosing the left or
        right partion to determine the median, explained below
         */
        // Here, we decide that left partition will have more elements
        int halfLen = (n + 1) / 2;
        if (n1 > n2)
            return findMedianSortedArrays(nums2, nums1);
        /*
        Before carrying on, let me just explain one simple concept: BOUNDARY LINE

        In an array of k elements, there are k+1 such boundary lines 
        separating the elements, running from 0,1,2,...,k-1,k

        the element to the left of jth boundary line will be array[j-1],
        and the element to the right of jth boundary line will be array[j]

        Okay let\'s move on
        */
        /*
        Here, we are working with the array of smaller size among the two.

        low denotes the array\'s first boundary line, and high denotes the 
        array\'s last boundary line. Using these 2 variables, we can find 
        the boundary line that partition the array into 2 parts of roughly
        equal sizes.
        */
        int low = 0;
        int high = n1;
        /*
        Let the Binary Search Begin !!!
        
        When low > high, it means we have explored all possible partitioning
        option but failed to find one that satisfies the outcome we want.
        */
        while (low <= high) {
            /*
            mid1 is the partitioning line between left and right partion of
            nums1. If mid1 = 2, this means there are 2 elements on the left
            of mid1.

            mid2 can be calculated using halfLen - mid1. Note that halfLen is
            the number of elements in the combined left partition, hence mid2
            will be the number of elements in nums2\'s left partition.

            !!! DO NOT try to see mid1 and mid2 as the index of element inside each 
            array, since it will fck with your brain (I made this mistake lol).
            Rather see them as the boundary line (or "guide" line) for determining 
            value for rightmost and leftmost elements of each partition !!!
            */
            // midpoint boundary line of nums1
            int mid1 = (low + high) / 2;
            // midpoint boundary line of nums2
            int mid2 = halfLen - mid1;
            /* 
            l1 denotes the left element to the boundary line mid1
            when mid1 = 0 (i.e the boundary line before the first element), 
            l1 should be set to NEG_INFINITY to facilitate comparision.
            */
            long l1 = mid1 >= 1 ? nums1[mid1 - 1] : Long.MIN_VALUE;
            /*
            r1 denotes the right element to boundary line mid1
            when mid1 = n1 (i.e the boundary line after last element of nums 1), 
            r1 should be set to POS_INFINITY for comparision
             */
            long r1 = mid1 < n1 ? nums1[mid1] : Long.MAX_VALUE;
            /* Similar logic to l1 and r1, l2 and r2 are the left and right 
            elements of mid2 */
            long l2 = mid2 >= 1 ? nums2[mid2 - 1] : Long.MIN_VALUE;
            long r2 = mid2 < n2 ? nums2[mid2] : Long.MAX_VALUE;
            /*
            When this condition is met, this means we are sure that all
            elements of combined left partition are less or equal to those
            of the combined right partition
            */
            if (l1 <= r2 && l2 <= r1) {
                if (n % 2 == 0) {
                    double left = Math.max(l1, l2);
                    double right = Math.min(r1, r2);
                    return (left + right) / 2;
                } else {
                    /*
                    Since we have decided that the left partition take the 
                    midpoint element if length is odd, we return the larger 
                    between l1 and l2.
                    */
                    return Math.max(l1, l2);
                    /* If we have otherwise decided that the right partition
                    should take midpoint in case of odd-length array 
                    (i.e halfLen = n/2), we will return the smaller value
                    between r1 and r2:
                        return Math.min(r1,r2)
                    */
                }
            } else /*
            otherwise, we want to move partitioning line towards the right of
            nums1, hoping to find a line that will make l2 <= r1;
            */
            if (l2 > r1)
                low = mid1 + 1;
            else /*
            if l1 > r2, we should move the partioning line towards the left of
            nums1, in hope that we do find a partioning line that make l1 <= r2 
            */
            if (l1 > r2)
                high = mid1 - 1;
            /*
            Note that in the case both l2 > r1 and l1 > r2 are true, it does not
            matter if we move towards the left first, or towards the right first.
            We will end up having the same result.
            */
        }
        return 0;
    }
}
