class Solution {

    // In our problem scenario every node can have at most one child
    HashMap<Integer, Integer> graph;

    // This DS will be used for two purpose
    // 1. To store the size of the graph from a given node
    // 2. To check whether we have already calculated the size of the graph from a given node
    HashMap<Integer, Integer> graphSize;

    int ans = 0;

    int calculateGraphSize(int node) {
        Integer childNode = graph.get(node);
        // no children of the current node
        if (childNode == null) {
            graphSize.put(node, 1);
        } else // if childnode is already traversed
        if (graphSize.get(childNode) > 0) {
            graphSize.put(node, graphSize.get(childNode) + 1);
        } else {
            // if child node is not traversed then traverse it
            int graphSizeFromChild = calculateGraphSize(childNode);
            this.graphSize.put(node, graphSizeFromChild + 1);
        }
        ans = Math.max(ans, graphSize.get(node));
        return graphSize.get(node);
    }

    void init(int[] nums) {
        graph = new HashMap<>();
        graphSize = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            // each node is not pointing to any other node at start
            graph.put(nums[i], null);
            // we initialize graphSize to 0 because
            graphSize.put(nums[i], 0);
        }
    }

    public int longestConsecutive(int[] nums) {
        // create a graph of n nodes where each node represents nums[i]
        init(nums);
        // complete the graph, always search for the next number and create a directed acyclic graph
        for (int i = 0; i < nums.length; i++) {
            int currNode = nums[i];
            int nextNode = currNode + 1;
            if (graph.containsKey(nextNode)) {
                // to make sure that duplicates aren\'t counted more than once
                // think about the case 4,4,5
                if (graph.get(currNode) == null) {
                    graph.put(currNode, nextNode);
                }
            }
        }
        // now run dfs on the connected components
        for (Integer key : graph.keySet()) {
            calculateGraphSize(key);
        }
        return ans;
    }
}
