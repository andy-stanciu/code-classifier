class Solution {

    public int longestConsecutive(int[] nums) {
        // Create a Directed Graph
        // INPUT :: int[]{100,4,200,1,3,2}
        // OUTPUT :: {1=2, 2=3, 3=4, 100=null, 4=null, 200=null}
        HashMap<Integer, Integer> graph = new HashMap<>();
        for (int num : nums) {
            if (graph.containsKey(num - 1)) {
                graph.put(num - 1, num);
            }
            if (graph.containsKey(num + 1)) {
                graph.put(num, num + 1);
            } else {
                graph.put(num, null);
            }
        }
        // Do DFS from every unvisited node and record path length
        // res[0] records path length for each DFS call
        int[] res = new int[] { 0 };
        Set<Integer> visited = new HashSet<>();
        // to track the max path length
        int M = Integer.MIN_VALUE;
        for (int key : graph.keySet()) {
            if (!visited.contains(key)) {
                dfsLC(graph, visited, 1, res, key);
                M = Math.max(M, res[0]);
                res[0] = 0;
            }
        }
        return Math.max(M, 0);
    }

    private void dfsLC(HashMap<Integer, Integer> graph, Set<Integer> visited, int i, int[] res, int key) {
        visited.add(key);
        if (graph.get(key) != null) {
            dfsLC(graph, visited, i + 1, res, graph.get(key));
        } else {
            res[0] = i;
        }
    }
}
