//BRUTE APPROACH
// class Solution {
//     public List<Integer> majorityElement(int[] nums) {
//         int n = nums.length;
//         List<Integer> result = new ArrayList<>();
//         for(int i=0; i<n; i++){
//             // Checking if nums[i] is not already a part of the answer:
//             if (result.size() == 0 || result.get(0) != nums[i]) {
//                 int count = 0;
//                 for (int j = 0; j < n; j++) {
//                     // counting the frequency of nums[i]
//                     if (nums[j] == nums[i]) {
//                         count++;
//                     }
//                 }
//                 // check if frquency is greater than n/3:
//                 if (count > (n / 3))
//                     result.add(nums[i]);
//             }
//             if (result.size() == 2) break;
//         }
//         return result;
//     }
// }
//BETTER APPROACH
// class Solution {
//     public List<Integer> majorityElement(int[] nums) {
//         int n = nums.length;
//         List<Integer> result = new ArrayList<>(); // list of answers
//         //declaring a map:
//         HashMap<Integer, Integer> map = new HashMap<>();
//         // least occurrence of the majority element:
//         int mini = (int)(n / 3) + 1;
//         //storing the elements with its occurnce:
//         for (int i = 0; i < n; i++) {
//             int value = map.getOrDefault(nums[i], 0);
//             map.put(nums[i], value + 1);
//             //checking if nums[i] is the majority element:
//             if (map.get(nums[i]) == mini) {
//                 result.add(nums[i]);
//             }
//             if (result.size() == 2) break;
//         }
//         return result;
//     }
// }
//OPTIMIZED APPROACH
class Solution {

    public List<Integer> majorityElement(int[] nums) {
        int n = nums.length;
        int count1 = 0;
        int maj1 = Integer.MIN_VALUE;
        int count2 = 0;
        int maj2 = Integer.MIN_VALUE;
        // Phase 1: Find potential candidates for majority elements
        for (int i = 0; i < n; i++) {
            if (nums[i] == maj1) {
                count1++;
            } else if (nums[i] == maj2) {
                count2++;
            } else if (count1 == 0) {
                maj1 = nums[i];
                count1 = 1;
            } else if (count2 == 0) {
                maj2 = nums[i];
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }
        // Phase 2: Verify the candidates
        List<Integer> result = new ArrayList<>();
        int freq1 = 0;
        int freq2 = 0;
        // Count the actual frequencies of maj1 and maj2
        for (int num : nums) {
            if (num == maj1)
                freq1++;
            else if (num == maj2)
                freq2++;
        }
        // If they appear more than n/3 times, add them to the result
        if (freq1 > n / 3) {
            result.add(maj1);
        }
        if (freq2 > n / 3) {
            result.add(maj2);
        }
        return result;
    }
}
