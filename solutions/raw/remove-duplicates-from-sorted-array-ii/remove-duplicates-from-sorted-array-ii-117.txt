class Solution {

    public int removeDuplicates(int[] nums) {
        // remove and keep 2 reduntant data in-place
        // # Intuition
        // Would use two pointer in order to use in place and keep time complexity
        // linear -->
        // # Approach
        // <!-- Would use two pointer in order to use in place and keep time complexity
        // linear and swap element with last elements of array as those would not be
        // counted //with one temp variable to mark duplicate data ,along side keeping
        // variable counter for 2 duplicate data
        // # Complexity
        // - Time complexity: O(n)
        // - Space complexity: O(1)
        int i = 1;
        int counter = 1;
        int n = nums.length;
        int temp = nums[0];
        for (int j = 1; j < n; ) {
            if (temp == nums[j]) {
                ++counter;
                if (j == n - 1 && (counter >= 2)) {
                    nums[i] = nums[j];
                    i++;
                }
                j++;
            } else {
                if (i != j) {
                    if (counter >= 2) {
                        nums[i] = temp;
                        i++;
                        nums[i] = nums[j];
                    } else {
                        nums[i] = nums[j];
                    }
                    counter = 1;
                }
                temp = nums[j];
                j++;
                i++;
            }
        }
        return i;
    }
}
