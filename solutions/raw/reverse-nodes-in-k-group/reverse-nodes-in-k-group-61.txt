/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode reverseKGroup(ListNode head, int k) {
        int count = 0;
        ListNode lazy = head, itr = head;
        while (itr != null && count < k) {
            //counting and extracting a group of K nodes
            lazy = itr;
            itr = itr.next;
            count++;
        }
        //If group of K nodes cannot be completed, leave them untouched
        if (count != k)
            return head;
        //Isolate the k-node linked list before reversing it to prevent any cycles.
        lazy.next = null;
        //Reverse and obtain the head of the linked list after the current K nodes.
        ListNode nexthead = reverseKGroup(itr, k);
        //Reverse the current List
        ListNode currhead = reverseList(head);
        //Stitch together the current reverse K-nodes and the result of the remaining list.
        head.next = nexthead;
        // Return the head of the current Linked list.
        return currhead;
    }

    public // Recursive function to reverse a linked list and return the head.
    // Recursive function to reverse a linked list and return the head.
    // Recursive function to reverse a linked list and return the head.
    ListNode reverseList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        ListNode revhead = reverseList(head.next);
        head.next.next = head;
        return revhead;
    }
}
