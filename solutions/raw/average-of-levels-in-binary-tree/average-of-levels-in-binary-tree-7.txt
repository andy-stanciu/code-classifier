/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
/*/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 /*

 // Dfs
class Solution {
    // Calculate the height of the tree
    public int height(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            return 1 + Math.max(height(root.left), height(root.right));
        }
    }

    // Calculate the sum and count of nodes at nth level
    public void nthlevel(TreeNode root, int n, double[] sumCount) {
        if (root == null) return;
        if (n == 1) {
            sumCount[0] += root.val;
            sumCount[1] += 1;
        } else {
            nthlevel(root.left, n - 1, sumCount);
            nthlevel(root.right, n - 1, sumCount);
        }
    }

    // Calculate the average of each level
    public List<Double> averageOfLevels(TreeNode root) {
        ArrayList<Double> ans = new ArrayList<>();
        int level = height(root);
        for (int i = 1; i <= level; i++) {
            double[] sumCount = new double[2]; // sumCount[0] for sum, sumCount[1] for count
            nthlevel(root, i, sumCount);
            double average = sumCount[0] / sumCount[1];
            ans.add(average);
        }
        return ans;
    }
}
*/
//BFS//
class Solution {

    public List<Double> averageOfLevels(TreeNode root) {
        ArrayList<Double> ans = new ArrayList<>();
        Queue<TreeNode> q1 = new LinkedList<>();
        q1.add(root);
        while (q1.size() > 0) {
            int n = q1.size();
            double sum = 0.000;
            for (int i = 0; i < n; i++) {
                TreeNode node = q1.poll();
                sum = sum + node.val;
                if (node.left != null)
                    q1.offer(node.left);
                if (node.right != null)
                    q1.offer(node.right);
            }
            ans.add(sum / n);
        }
        return ans;
    }
}
