/**
 * This is a recursive solution.
 *
 * It first finds the height of the tree. Once it knows the height, it iterates through i = 1 to i <= height. At each iteration,
 * it dives down into the tree recursively, to find all the nodes at the the particular i\'th layer, counting up the nodes,
 * adding to sum, so that when it\'s done with the layer, it can compute the layer\'s average.
 *
 * It\'s neat and doesn\'t need a queue, but it\'s sooo slow compared to the iterative solution. Not practical.
 */
class Solution {

    private int count;

    private long sum;

    public List<Double> averageOfLevels(TreeNode root) {
        List<Double> list = new ArrayList<>();
        int height = height(root);
        for (int i = 1; i <= height; i++) {
            count = 0;
            sum = 0;
            visitLevel(root, i);
            double avg = (double) sum / (double) count;
            list.add(avg);
        }
        return list;
    }

    private void visitLevel(TreeNode node, int level) {
        if (node == null)
            return;
        if (level == 1) {
            // visit
            count++;
            sum += node.val;
        } else if (level > 1) {
            visitLevel(node.left, level - 1);
            visitLevel(node.right, level - 1);
        }
    }

    private int height(TreeNode n) {
        if (n == null)
            return 0;
        int leftHeight = height(n.left);
        int rightHeight = height(n.right);
        return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;
    }
}
