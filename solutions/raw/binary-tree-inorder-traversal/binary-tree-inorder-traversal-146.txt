class Solution {

    List<Integer> list = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        // if we found graph with no node , it return list that contains null values.
        if (root == null)
            return list;
        // it find inorder in a graph.
        inorder(root);
        // it return list that contains inorder values.
        return list;
    }

    void inorder(TreeNode r) {
        if (// if root node null it stop receiving in a graph.
        r != null) {
            /*
             An inorder traversal technique follows the Left Root Right policy.
             Here, Left Root Right means that the left subtree of the root node is traversed first,
             then the root node, and then the right subtree of the root node is traversed.
             (LPR).
            */
            //it travels left part of tree, recursive call inorder.
            inorder(r.left);
            // it add root node in answer list.
            list.add(r.val);
            //it travels right part of tree, recursive call inorder.
            inorder(r.right);
        }
    }
}
