/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public List<Integer> inorderTraversal(TreeNode root) {
        //initialize list
        ArrayList<Integer> treeList = new ArrayList<Integer>();
        //start the recursive function at the root layer
        inOrderTraversalDepthFirstSearch(treeList, root);
        return treeList;
    }

    //list is fed to this function in order to recursively populate it in order from leftmost node to rightmost node
    public void inOrderTraversalDepthFirstSearch(List<Integer> treeList, TreeNode node) {
        //if node fed is somehow null (e.g. whole tree is empty) then this entire function isn\'t triggered
        if (node != null) {
            //search left side first recursively until you reach null
            if (node.left != null) {
                inOrderTraversalDepthFirstSearch(treeList, node.left);
            }
            //once you\'ve gone to the far left end of the tree we can start adding to the list (remember global stack is "last in first out" so the far left node gets pushed to list first)
            treeList.add(node.val);
            //Then once that\'s done search the right side(it will immediatley go to the right sides leftmost node first due to the recursive behaviour above before it starts adding the right side in)
            if (node.right != null) {
                inOrderTraversalDepthFirstSearch(treeList, node.right);
            }
            //we don\'t need to add the node value here as remember this is all one function and it\'s been done already on the line above before this, we should successfully have gone through the whole tree in inorder traversal
        }
    }
}
