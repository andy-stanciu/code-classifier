/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    // public List<Integer> inorderTraversal(TreeNode root) {
    //     List<Integer> result = new ArrayList<>();
    //     Stack<TreeNode> stack = new Stack<>();
    //     TreeNode node = root;
    //     while(true){
    //         if(node != null){
    //             stack.push(node);
    //             node = node.left;
    //         }else{
    //             if(stack.isEmpty()) break;
    //             node = stack.pop();
    //             result.add(node.val);
    //             node = node.right;
    //         }
    //     }
    //     return result;
    // }
    public List<Integer> inorderTraversal(TreeNode root) {
        // List to store the inorder traversal result
        List<Integer> inorderList = new ArrayList<>();
        TreeNode currentNode = root;
        while (currentNode != null) {
            // If there\'s no left child, add the current node\'s value
            // and move to the right child
            if (currentNode.left == null) {
                inorderList.add(currentNode.val);
                currentNode = currentNode.right;
            } else {
                // Find the rightmost node in the left subtree
                // of the current node
                TreeNode rightmost = currentNode.left;
                while (rightmost.right != null && rightmost.right != currentNode) {
                    rightmost = rightmost.right;
                }
                // If the rightmost node\'s right pointer is null,
                // link it to the current node
                if (rightmost.right == null) {
                    rightmost.right = currentNode;
                    currentNode = currentNode.left;
                } else {
                    // If the link already exists, remove it, add
                    // the current node\'s value, and move to the right child
                    rightmost.right = null;
                    inorderList.add(currentNode.val);
                    currentNode = currentNode.right;
                }
            }
        }
        return inorderList;
    }
}
