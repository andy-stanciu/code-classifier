class Solution {

    public int firstMissingPositive(int[] nums) {
        // HashSet<Integer>hs=new HashSet<>();
        // for (int a:nums)
        // {
        //     // we know that zero is consider that non positive and
        //     // non negative in programming
        //     //We don\'t care about duplicates or non-positive integers
        //     if (a>0)
        //     {
        //         hs.add(a);
        //     }
        // }
        // for (int i=1;i<=nums.length+1;i++)
        // {
        //     if (!hs.contains(i))
        //     {
        //         return i;
        //     }
        // }
        // return -1;
        // hashset approach takes tc O(n) also space O(n) worst case
        // now by using cyclic sort
        // sort elements by finding arr[i]!=arr[arr[i]-1]
        int i = 0;
        /// for sorting using cyclic sort
        while (i < nums.length) {
            if (// it is good to make a separate function for swapping
            nums[i] > 0 && nums[i] < nums.length && nums[i] != nums[nums[i] - 1]) {
                int temp = nums[i];
                nums[i] = nums[nums[i] - 1];
                nums[temp - 1] = temp;
            } else {
                i++;
            }
        }
        // finding missing positive number
        // it means nums[0]=1,nums[1]=2, ....
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] != j + 1) {
                return j + 1;
            }
        }
        return nums.length + 1;
    }
}
