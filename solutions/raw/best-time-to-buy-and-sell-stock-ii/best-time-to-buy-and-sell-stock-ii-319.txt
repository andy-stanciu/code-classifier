class Solution {

    public int maxProfit(int[] prices) {
        int n = prices.length;
        // int[][]dp=new int[n+1][2];
        // for(int[]row:dp) Arrays.fill(row,-1);
        // return findRecur(0,0,prices,dp);
        //Tabulation
        // Time = O(n*2);
        // Space = O(n*2)
        // dp[n][0]=0;dp[n][1]=0;
        // for(int i=n-1;i>=0;i--){
        //     for(int j=1;j>=0;j--){
        //         int profit=Integer.MIN_VALUE;
        //         if(j==0){
        //             profit=Math.max(-prices[i]+dp[i+1][1],0+dp[i+1][0]);
        //         }else {
        //             profit=Math.max(prices[i]+dp[i+1][0],0+dp[i+1][1]);
        //         }
        //         dp[i][j]=profit;
        //     }
        // }
        // return dp[0][0];
        //Space Optimization
        // Time = O(n*2);
        // Space = O(2*2)
        int[] nextRow = new int[2];
        int[] cur = new int[2];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 1; j >= 0; j--) {
                int profit = Integer.MIN_VALUE;
                if (j == 0) {
                    profit = Math.max(-prices[i] + nextRow[1], 0 + nextRow[0]);
                } else {
                    profit = Math.max(prices[i] + nextRow[0], 0 + nextRow[1]);
                }
                cur[j] = profit;
            }
            nextRow = cur;
        }
        return nextRow[0];
    }

    //Memoization
    // Time = O(n*2);
    // Space = O(n*2) + O(n)
    public int findRecur(int idx, int buy, int[] prices, int[][] dp) {
        if (idx == prices.length)
            return 0;
        if (dp[idx][buy] != -1)
            return dp[idx][buy];
        int profit = Integer.MIN_VALUE;
        if (buy == 0) {
            profit = Math.max(-prices[idx] + findRecur(idx + 1, 1, prices, dp), 0 + findRecur(idx + 1, 0, prices, dp));
        } else {
            profit = Math.max(prices[idx] + findRecur(idx + 1, 0, prices, dp), 0 + findRecur(idx + 1, 1, prices, dp));
        }
        return dp[idx][buy] = profit;
    }
}
