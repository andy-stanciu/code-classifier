class Solution {

    Random random = new Random();

    public int findKthLargest(int[] nums, int k) {
        if (nums == null || nums.length == 0)
            return Integer.MIN_VALUE;
        int n = nums.length;
        int low = 0;
        int high = n - 1;
        while (low < high) {
            int[] partition = _3WayPartition(nums, low, high);
            if (partition[0] > n - k) {
                high = partition[0] - 1;
            } else if (partition[1] < n - k)
                low = partition[1] + 1;
            else if (partition[0] <= n - k && partition[1] >= n - k)
                break;
        }
        return nums[n - k];
    }

    private int[] _3WayPartition(int[] nums, int low, int high) {
        // to avoid hitting the worst case, assume an array is sorted ascending order
        // randomize pivot/boundary
        int randomIdx = low + random.nextInt(high - low + 1);
        swap(nums, randomIdx, low);
        //leftBoundary denotes the left index of the pivot element
        int leftBoundary = low;
        //rightBoundary denotes the right index of the pivot element
        //same as pivot
        int rightBoundary = high;
        int pivotElement = nums[leftBoundary];
        int l = low + 1;
        while (l <= rightBoundary) {
            //the current element is lesser than a pivot element, hence the left boundary needs to change ; the element should be on the left side
            if (nums[l] < pivotElement) {
                swap(nums, l, leftBoundary);
                l++;
                leftBoundary++;
            } else if (nums[l] > pivotElement) {
                //the current element is greater than a pivot element, hence the right boundary needs to change; the element should be on the right side
                swap(nums, l, rightBoundary);
                rightBoundary--;
            } else if (nums[l] == pivotElement) {
                //skip such duplicate elements, hence move to next element
                l++;
            }
        }
        return new int[] { leftBoundary, rightBoundary };
    }

    private void swap(int[] nums, int l, int r) {
        int temp = nums[l];
        nums[l] = nums[r];
        nums[r] = temp;
    }
}
