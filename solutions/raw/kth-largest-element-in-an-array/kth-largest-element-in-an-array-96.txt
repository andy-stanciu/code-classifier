class Solution {

    // quickselect solution
    // public int findKthLargest(int[] nums, int k) {
    //     int low=0, high=nums.length-1;
    //     Random rand=new Random();
    //     while(true) {
    //         int intitalPivotIndex = low+rand.nextInt(high-low+1);
    //         int pivInd = partition(nums, low, high, intitalPivotIndex);
    //         if (pivInd==nums.length-k)
    //             return nums[pivInd];
    //         else if (pivInd < nums.length-k)
    //             low = pivInd+1;
    //         else
    //             high = pivInd-1;
    //     }
    // }
    // private void swap(int[] nums, int i, int j) {
    //     int temp = nums[i];
    //     nums[i] = nums[j];
    //     nums[j] = temp;
    // }
    // private int partition(int[] nums, int low, int high, int pivotIndex) {
    //     int storedIndex = low, pivot = nums[pivotIndex];
    //     swap(nums, pivotIndex, high);
    //     for (int j=low; j<high; j++) {
    //         if (nums[j] < pivot) {
    //             swap(nums, storedIndex, j);
    //             storedIndex++;
    //         }
    //     }
    //     swap(nums, high, storedIndex);
    //     return storedIndex;
    // }
    // maxHeap solution
    // public int findKthLargest(int[] nums, int k) {
    //     PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
    //     for (int num: nums) {
    //         maxHeap.add(num);
    //     }
    //     for (int i=0; i<k-1; i++) {
    //         maxHeap.poll();
    //     }
    //     return maxHeap.poll();
    // }
    // minHeap solution
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int i = 0; i < k; i++) {
            minHeap.add(nums[i]);
        }
        int head = minHeap.peek();
        for (int i = k; i < nums.length; i++) {
            if (nums[i] > head) {
                minHeap.poll();
                minHeap.offer(nums[i]);
                head = minHeap.peek();
            }
        }
        return minHeap.poll();
    }
}
