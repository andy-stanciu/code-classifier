/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int maxPathSum(TreeNode root) {
        //base cases
        if (root == null) {
            return 0;
        }
        Stack<Pair<TreeNode, Integer>> stack = new Stack<Pair<TreeNode, Integer>>();
        stack.push(new Pair<TreeNode, Integer>(root, 0));
        int max_sum = Integer.MIN_VALUE;
        while (!stack.isEmpty()) {
            Pair<TreeNode, Integer> top = stack.pop();
            TreeNode topNode = top.getKey();
            int state = top.getValue();
            if (state == 0) {
                stack.push(new Pair<TreeNode, Integer>(topNode, state + 1));
                if (topNode.left != null) {
                    stack.push(new Pair<TreeNode, Integer>(topNode.left, state));
                }
            } else if (state == 1) {
                stack.push(new Pair<TreeNode, Integer>(topNode, state + 1));
                if (topNode.right != null) {
                    stack.push(new Pair<TreeNode, Integer>(topNode.right, state - 1));
                }
            } else {
                int left_sum = (topNode.left != null) ? topNode.left.val : 0;
                int right_sum = (topNode.right != null) ? topNode.right.val : 0;
                max_sum = Math.max(max_sum, topNode.val + Math.max(0, left_sum) + Math.max(0, right_sum));
                int max_child_sum = Math.max(left_sum, right_sum);
                topNode.val += Math.max(0, max_child_sum);
            }
        }
        return max_sum;
    }
}
