class Solution {

    // Variable to store the maximum path sum found so far
    int max = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        // Call the dfs function starting from the root node
        dfs(root);
        // Return the maximum path sum
        return max;
    }

    public int dfs(TreeNode root) {
        // Base case: If the node is null, return 0
        if (root == null)
            return 0;
        // Recursively calculate the maximum path sum for the left and right subtrees
        // If the left path sum is negative, consider it as 0
        int l = Math.max(0, dfs(root.left));
        // If the right path sum is negative, consider it as 0
        int r = Math.max(0, dfs(root.right));
        // Update the maximum path sum with the sum of the current node\'s value and the maximum path sums from left and right subtrees
        max = Math.max(max, l + r + root.val);
        // Return the maximum path sum including the current node\'s value
        // This ensures that we consider only one path (either left or right) to the parent node
        return root.val + Math.max(l, r);
    }
}
