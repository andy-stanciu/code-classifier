/*
explanation: course schedule using kahn sort, the algorithm works by first converting the given problem
to graph and applying a simple topological sort to get the order of finishing, if any of such order is possible
then we check for more order, in the end we compare this size of list with the total number of element it should be and if they are same then we can finish all courses!

testcase:  [[1,0]] -> Works

Time & Space Complexity: O(V+E) & O(V+E): Time and space complexity are both v+e due to graph algorithm used
*/
class G {

    HashMap<Integer, List<Integer>> adjaceList;

    int vertices;

    int edges;

    int[] visited;

    int[] indegrees;

    G(int v, int e) {
        vertices = v;
        edges = e;
        adjaceList = new HashMap<>();
        // to store and retrieve visited nodes!
        visited = new int[vertices];
        Arrays.fill(visited, 0);
        // Indegrees calculate (ie incoming edge, for each node)
        indegrees = new int[vertices];
        Arrays.fill(indegrees, 0);
    }

    void _add(int a, int b) {
        List<Integer> elements = adjaceList.getOrDefault(a, new ArrayList<>());
        elements.add(b);
        adjaceList.put(a, elements);
        // Increase indegree to b
        indegrees[b]++;
    }

    void feed(int a, int b) {
        _add(a, b);
        _add(b, a);
    }

    List<Integer> get(int a) {
        // Mark it as visited!
        visited[a] = 1;
        return adjaceList.getOrDefault(a, new ArrayList<>());
    }

    Boolean isVisited(int a) {
        return visited[a] != 0;
    }

    void clear() {
        Arrays.fill(visited, 0);
    }
}

class Solution {

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // Build graph!
        G graph = new G(numCourses, prerequisites.length);
        for (int[] arr : prerequisites) {
            graph._add(arr[0], arr[1]);
        }
        Queue<Integer> queue = new LinkedList<>();
        // Now do kahn sort!
        for (int i = 0; i < graph.indegrees.length; i++) {
            if (graph.indegrees[i] == 0)
                queue.add(i);
        }
        List<Integer> ans = new ArrayList<>();
        // Now start unwrapping
        while (queue.size() > 0) {
            int element = queue.poll();
            // Add to our list
            ans.add(element);
            // Get neighbours
            List<Integer> nn = graph.get(element);
            for (Integer n : nn) {
                graph.indegrees[n]--;
                if (graph.indegrees[n] == 0 && !graph.isVisited(n)) {
                    queue.add(n);
                }
            }
        }
        return ans.size() == numCourses;
    }
}
