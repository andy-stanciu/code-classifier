class Solution {

    Map<Integer, Boolean> mem = new HashMap<>();

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int[] a : prerequisites) {
            map.computeIfAbsent(a[0], k -> new ArrayList<>()).add(a[1]);
        }
        int count = 0;
        for (int i = 0; i < numCourses; i++) {
            Set<Integer> visited = new HashSet<>();
            if (fun(map, i, visited)) {
                count++;
                // System.out.println("i " + i + " count " + count);
            }
        }
        return count >= numCourses;
    }

    public boolean fun(Map<Integer, List<Integer>> map, int c, Set<Integer> visited) {
        if (visited.contains(c)) {
            return false;
        }
        if (mem.containsKey(c)) {
            return mem.get(c);
        }
        int count = 0;
        if (map.containsKey(c)) {
            List<Integer> courses = map.get(c);
            for (Integer cc : courses) {
                visited.add(c);
                boolean ret = fun(map, cc, visited);
                mem.put(cc, ret);
                if (!ret) {
                    return false;
                }
                //revert as 1 course have multiple pre,dfs independetly [[1,0],[2,6],[1,7],[6,4],[7,0],[0,5]]
                visited.remove(c);
            }
            return true;
        }
        return true;
    }
}
