class Solution {

    private boolean[] visited;

    private boolean[] onStack;

    private Map<Integer, Set<Integer>> graph;

    private int[] inDegree;

    private int n;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        visited = new boolean[numCourses];
        onStack = new boolean[numCourses];
        inDegree = new int[numCourses];
        graph = new HashMap<Integer, Set<Integer>>();
        n = numCourses;
        for (int i = 0; i < numCourses; i++) {
            graph.put(i, new HashSet<Integer>());
        }
        for (int[] prerequisite : prerequisites) {
            graph.get(prerequisite[0]).add(prerequisite[1]);
            inDegree[prerequisite[1]]++;
        }
        return solve(2);
    }

    private boolean solve(int method) {
        boolean can = true;
        switch(method) {
            case 1:
                can = _1_canFinish();
                break;
            case 2:
                can = _2_canFinish();
                break;
        }
        return can;
    }

    private boolean _1_canFinish() {
        for (int i = 0; i < n; i++) {
            if (hasCycle(i)) {
                return false;
            }
        }
        return true;
    }

    private boolean _2_canFinish() {
        Queue<Integer> canComplete = new ArrayDeque<Integer>();
        int completedCount = 0;
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == 0) {
                canComplete.add(i);
            }
        }
        while (!canComplete.isEmpty()) {
            int completed = canComplete.remove();
            completedCount++;
            for (int dependent : graph.get(completed)) {
                inDegree[dependent]--;
                if (inDegree[dependent] == 0) {
                    canComplete.add(dependent);
                }
            }
        }
        return completedCount == n;
    }

    private boolean hasCycle(int v) {
        if (onStack[v])
            return true;
        if (visited[v])
            return false;
        visited[v] = true;
        onStack[v] = true;
        for (int w : graph.get(v)) {
            if (hasCycle(w)) {
                return true;
            }
        }
        onStack[v] = false;
        return false;
    }
}
