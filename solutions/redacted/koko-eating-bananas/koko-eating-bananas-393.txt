class Solution {

    // Algo Used: Binary Search
    // TC: O N LogN
    // SC: O 1
    public int method1(int[] piles, int h) {
        int n = piles.length;
        int start = 1;
        int end = 0;
        for (int i = 0; i < n; i++) {
            // Finding the max ele.
            end = Math.max(end, piles[i]);
        }
        // Edge case:
        if (h == piles.length)
            return end;
        while (start <= end) {
            // we are treating mid as k
            int mid = start + (end - start) / 2;
            int tempH = 0;
            int k = mid;
            for (int i = 0; i < n; i++) {
                // This will calculate the how many time a curr pile will take,
                tempH += piles[i] / k;
                // supppose for 3 / 5 it will give ans as 1,
                if (piles[i] % k > 0) {
                    // and this will do 3 % 5 in which remainder is > 0 i.e 2,
                    //so it will do tempH++, so now tempH value will be -> 1 from 3 / 5 and adding 1 from 3 % 5
                    tempH++;
                }
            }
            if (tempH <= h && tempH > 0) {
                // if tempH is still not reached h then we have more space left, so we can try with a shorter number.
                end = mid - 1;
            } else {
                // if tempH exceeds then try increasing the size of mid to reduce the gap.
                start = mid + 1;
            }
        }
        return start;
    }
}
