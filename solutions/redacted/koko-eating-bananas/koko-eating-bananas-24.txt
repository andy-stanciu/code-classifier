class Solution {

    public static boolean method1(double speed, int totalTime, int[] param1) {
        double timeTaken = 0;
        for (int i = 0; i < param1.length; i++) {
            // we calculate the time taken
            double t = (double) param1[i] / speed;
            // if the time taken is something like 1.5 then
            //koko will wait till 2 so we use math. ceil
            t = Math.ceil(t);
            timeTaken += t;
            //we check if the given speed is enough.
            if (timeTaken > totalTime)
                return false;
        }
        return true;
    }

    public static int method2(int[] param1, int totalTime) {
        double maxSpeed = 0;
        double minSpeed = Integer.MAX_VALUE;
        for (int i = 0; i < param1.length; i++) {
            if (maxSpeed < param1[i])
                maxSpeed = param1[i];
            if (minSpeed > param1[i])
                minSpeed = param1[i];
        }
        //minSpeed and maxSpeed are the smallest and the biggest values
        //in the array. This will serve us our range for binary search
        if (maxSpeed == minSpeed) {
            // we come into a problem where all the items are equal
            // where maxSpeed == minSpeed, so this will tackle that problem
            if (param1.length <= totalTime && totalTime / param1.length == 1)
                return (int) maxSpeed;
            return (int) (Math.ceil((maxSpeed * param1.length) / totalTime));
        }
        minSpeed = minSpeed / totalTime;
        while (minSpeed < maxSpeed) {
            double mid = minSpeed + (maxSpeed - minSpeed) / 2;
            if (method1(mid, totalTime, param1))
                maxSpeed = mid;
            else
                minSpeed = Math.ceil(mid);
        }
        return (int) minSpeed;
    }
}
