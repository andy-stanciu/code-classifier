class Solution {

    //    Set<String> wordDic = new HashSet<>();
    //     char[][] isVis;
    //     // Recursive function to check if the substring str[s:e] can be segmented
    //     char breakWord(String str, int s, int e) {
    //         if (isVis[s][e] != \'\\u0000\') return isVis[s][e];  // Return the cached result if available
    //         isVis[s][e] = \'v\';  // Mark this substring as visited
    //         char result = \'f\';
    //         // If the whole substring is a word in the dictionary, return \'t\' (true)
    //         if (wordDic.contains(str.substring(s, e))) {
    //             isVis[s][e] = \'t\';
    //             return \'t\';
    //         }
    //         // Try splitting the substring at different positions and check recursively
    //         for (int i = s + 1; i < e; i++) {
    //             if (breakWord(str, s, i) == \'t\' && breakWord(str, i, e) == \'t\') {
    //                 result = \'t\';
    //                 break;
    //             }
    //         }
    //         isVis[s][e] = result;
    //         return result;
    //     }
    //or
    public boolean method1(String s, List<String> param1) {
        // wordDic.addAll(wordDict);
        // isVis = new char[s.length() + 1][s.length() + 1];
        // return breakWord(s, 0, s.length()) == \'t\';
        Set<String> var1 = new HashSet<>(param1);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        // Base case: an empty string can be segmented
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && var1.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
