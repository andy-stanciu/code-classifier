//BRUTE APPROACH
//// class Solution {
//     public void merge(int[] nums1, int m, int[] nums2, int n) {
//         // Create a new array to store the merged elements
//         int[] mergedArray = new int[m + n];
//         // Copy elements from nums1 and nums2 into mergedArray
//         for (int i = 0; i < m; i++) {
//             mergedArray[i] = nums1[i];
//         }
//         for (int j = 0; j < n; j++) {
//             mergedArray[m + j] = nums2[j];
//         }
//         // Sort the merged array
//         Arrays.sort(mergedArray);
//         // Copy the sorted elements back to nums1
//         for (int k = 0; k < m + n; k++) {
//             nums1[k] = mergedArray[k];
//         }
//     }
// }
//BETTER APPROACH
// class Solution {
//     public void merge(int[] nums1, int m, int[] nums2, int n) {
//         // New array to store merged result
//         int[] mergedArray = new int[m + n];
//         int i = 0, j = 0, k = 0;
//         // Merge arrays until one is exhausted
//         while (i < m && j < n) {
//             if (nums1[i] <= nums2[j]) {
//                 mergedArray[k++] = nums1[i++];
//             } else {
//                 mergedArray[k++] = nums2[j++];
//             }
//         }
//         // If nums1 has remaining elements
//         while (i < m) {
//             mergedArray[k++] = nums1[i++];
//         }
//         // If nums2 has remaining elements
//         while (j < n) {
//             mergedArray[k++] = nums2[j++];
//         }
//         // Copy mergedArray back to nums1
//         for (int x = 0; x < m + n; x++) {
//             nums1[x] = mergedArray[x];
//         }
//     }
// }
//OPTIMAL SOLUTION
class Solution {

    public void method1(int[] nums1, int m, int[] nums2, int n) {
        // Pointer for nums1
        int i = m - 1;
        // Pointer for nums2
        int j = n - 1;
        // Pointer for nums1\'s end
        int k = m + n - 1;
        // Merge nums1 and nums2 starting from the back
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        // If nums2 still has elements left, copy them to nums1
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
}
