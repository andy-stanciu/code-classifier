//OPTIMIZED APPROACH
// class Solution {
//     public int maxProfit(int[] prices) {
//         //at the beginning the minimum price is the first price
//         int buy_price = prices[0];
//         //at the beginning the minimum profit is zero
//         int profit = 0;
//         for(int i = 1; i < prices.length; i++){
//             //if the current price is less update the buy_price
//             if(prices[i] < buy_price){
//                 buy_price = prices[i];
//             }
//             else{
//                 //else check if we can get a better profit
//                 int current_profit = prices[i] - buy_price;
//                 profit = Math.max(current_profit, profit);
//             }
//         }
//         return profit;
//     }
// }
//The time complexity is O(n) coz we traversed the array only once
//space complexity is O(1) coz we haven\'t took any extra space
//BRUTE FORCE APPROACH
// class Solution {
//     public int maxProfit(int[] prices) {
//         int maxProfit = 0;
//         int n = prices.length;
//         // Try every pair of days
//         for(int i = 0; i < n-1; i++){
//             for(int j = i+1; j < n; j++){
//                 int profit = prices[j] - prices[i];
//                 maxProfit = Math.max(maxProfit, profit);
//             }
//         }
//         return maxProfit;
//     }
// }
//BETTER APPROACH
class Solution {

    public int maxProfit(int[] prices) {
        int maxCurrent = 0;
        int maxSoFar = 0;
        for (int i = 1; i < prices.length; i++) {
            // Calculate the difference between the current price and the previous price
            int diff = prices[i] - prices[i - 1];
            // Apply Kadane\'s algorithm to find the maximum sum of the subarray
            maxCurrent = Math.max(0, maxCurrent + diff);
            maxSoFar = Math.max(maxSoFar, maxCurrent);
        }
        return maxSoFar;
    }
}
