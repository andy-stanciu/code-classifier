// class Solution {
//     public int maxProfit(int[] prices) {
//         return maxProfitRec(prices, 0, true);
//     }
//     private int maxProfitRec(int[] prices, int index, boolean canBuy) {
//         int n = prices.length;
//         // Base case: If we have reached the end of the prices array
//         if (index >= n) {
//             return 0;
//         }
//         // If we can buy on the current day
//         if (canBuy) {
//             // Either buy today or skip buying
//             int buy = -prices[index] + maxProfitRec(prices, index + 1, false);
//             int skip = maxProfitRec(prices, index + 1, true);
//             return Math.max(buy, skip);
//         } else {
//             // If we cannot buy, we can sell or skip selling
//             int sell = prices[index] + maxProfitRec(prices, index + 1, true);
//             int skip = maxProfitRec(prices, index + 1, false);
//             return Math.max(sell, skip);
//         }
//     }
// }
//ANOTHER MORE OPTIMAL GREEDY APPROACH
class Solution {

    public int maxProfit(int[] prices) {
        // Edge case: no prices
        if (prices.length == 0)
            return 0;
        // Initialize minPrice to a very large number
        int minPrice = Integer.MAX_VALUE;
        // Initialize maxProfit to 0
        int maxProfit = 0;
        // Iterate through each price
        for (int price : prices) {
            // Update minPrice if the current price is lower
            if (price < minPrice) {
                minPrice = price;
            }
            // Calculate the potential profit if sold at the current price
            int profit = price - minPrice;
            // Update maxProfit if the current profit is higher
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
        // Return the maximum profit found
        return maxProfit;
    }
}
