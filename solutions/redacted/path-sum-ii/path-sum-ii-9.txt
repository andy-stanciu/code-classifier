class Solution {

    public List<List<Integer>> method1(TreeNode root, int param1) {
        List<Integer> var1 = new ArrayList();
        List<List<Integer>> var2 = new ArrayList();
        method2(root, param1, var1, var2);
        return var2;
    }

    private static void method2(TreeNode currentNode, int param2, List<Integer> var1, List<List<Integer>> var2) {
        if (currentNode == null)
            return;
        // add the current node to the path
        var1.add(currentNode.val);
        // if the current node is a leaf and its value is equal to sum, save the current path
        if (currentNode.val == param2 && currentNode.left == null && currentNode.right == null)
            var2.add(new ArrayList<Integer>(var1));
        else {
            // traverse the left sub-tree
            method2(currentNode.left, param2 - currentNode.val, var1, var2);
            // traverse the right sub-tree
            method2(currentNode.right, param2 - currentNode.val, var1, var2);
        }
        // remove the current node from the path to backtrack,
        // we need to remove the current node while we are going up the recursive call stack.
        var1.remove(var1.size() - 1);
    }
}
