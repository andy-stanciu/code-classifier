/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public List<List<Integer>> method1(TreeNode root, int param1) {
        /*
        This problem has been asked in below companies:
        Bloomberg
        Amazon
        Adobe


        Time complexity: O(n^2)
        As we are visiting all the nodes in the tree and once we found our path , n times
        we are doing copy from one list to a new list - n times

        In the worst case it could be possible that we need to do copy in all leaf nodes
        and we in a complete tree there will be maximum nodes present in the last level

        so total time complexity: n * n


        Space complexity: O(n + h)

        n is for the path list where are adding the node value
        and h is for the recursion stack it could be log n or n

        so total space complexity is O(n) we can say in worst case
        Note that: we are not considering the output list space

        A good article where we should consider the output space or not:
        https://cs.stackexchange.com/questions/83574/does-space-complexity-analysis-usually-include-output-space
        */
        // to store all the paths
        List<List<Integer>> var1 = new ArrayList<>();
        // to store the running path
        List<Integer> var2 = new ArrayList<>();
        method1(root, param1, var2, var1);
        return var1;
    }

    public void method1(TreeNode root, int param1, List<Integer> var2, List<List<Integer>> var1) {
        // base case
        if (root == null)
            return;
        // add the current node value in path
        var2.add(root.val);
        // if it is leaf node and the value remaining is equal to the value of the current node
        // add the path into the pathlist
        // before add we need to create an another object and copy all values from path to newly created object
        if (param1 == root.val && root.left == null && root.right == null) {
            var1.add(new ArrayList<Integer>(var2));
        } else // otherwise find left side and right side
        {
            method1(root.left, param1 - root.val, var2, var1);
            method1(root.right, param1 - root.val, var2, var1);
        }
        // we need to remove the elements also which we added
        // because while going up from the recursion we dont want to remain the current value present
        // in the path list
        var2.remove(var2.size() - 1);
    }
}
