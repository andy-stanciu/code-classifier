class Solution {

    public boolean method1(int[] nums, int k) {
        // approach that we use is sliding window
        // initializing left pointer
        int l = 0;
        // initializing hashset to contain only unique values
        HashSet<Integer> set = new HashSet();
        // iterating in the array using the sliding window, where r is the right pointer
        for (int r = 0; r < nums.length; r++) {
            // we use the negative approach, so in the case where we encounter a duplicate
            while (set.contains(nums[r])) {
                // this is the case we are checking for as given in the question
                if (nums[r] == nums[l] && (r - l) <= k)
                    return true;
                // incase the above condition is not met with we remove the value at l pointer from the set
                set.remove(nums[l]);
                l++;
            }
            // as we are following a negative approach we add the value to the set now
            set.add(nums[r]);
        }
        // base condition (incase we do not find the value)
        return false;
    }
}
