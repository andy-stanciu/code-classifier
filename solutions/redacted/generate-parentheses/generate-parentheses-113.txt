class Solution {

    // This method generates all combinations of well-formed parentheses for a given number `n`
    public List<String> method1(int n) {
        // List to store all valid parentheses combinations
        List<String> ans = new ArrayList<>();
        // Start the recursive function with an empty string, zero open and close parentheses, and the total number of pairs `n`
        solve("", 0, 0, n, ans);
        // Return the final list of valid combinations
        return ans;
    }

    // Helper method to generate valid parentheses combinations recursively
    private void solve(String curr, int open, int close, int total, List<String> ans) {
        // Base case: If the current string length equals 2 * total, a complete combination is formed
        if (curr.length() == 2 * total) {
            // Add the current combination to the answer list
            ans.add(curr);
            // Return to backtrack and explore other possibilities
            return;
        }
        // If the number of open parentheses used is less than the total number of pairs, add an open parenthesis
        if (open < total) {
            solve(curr + "(", open + 1, close, total, ans);
        }
        // If the number of close parentheses used is less than the number of open parentheses, add a close parenthesis
        if (close < open) {
            solve(curr + ")", open, close + 1, total, ans);
        }
    }
}
