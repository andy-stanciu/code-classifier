/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public List<List<Integer>> method1(TreeNode root) {
        Map<Integer, List<Integer>> var1 = new HashMap<>();
        if (root != null) {
            Queue<NodePosition> BFS = new LinkedList<>();
            BFS.add(new NodePosition(root, 0, true));
            NodePosition currentNodePosition;
            TreeNode currentNode;
            int var2;
            boolean var3;
            while (!BFS.isEmpty()) {
                currentNodePosition = BFS.poll();
                currentNode = currentNodePosition.node;
                var2 = currentNodePosition.var4;
                var3 = !currentNodePosition.var3;
                if (!var1.containsKey(var2))
                    var1.put(var2, new LinkedList<>());
                if (var3)
                    var1.get(var2).addFirst(currentNode.val);
                else
                    var1.get(var2).add(currentNode.val);
                if (currentNode.left != null)
                    BFS.add(new NodePosition(currentNode.left, var2 + 1, var3));
                if (currentNode.right != null)
                    BFS.add(new NodePosition(currentNode.right, var2 + 1, var3));
            }
        }
        return new LinkedList<>(var1.values());
    }

    private static class NodePosition {

        private TreeNode node;

        private int var4;

        private boolean var3;

        public NodePosition(TreeNode node, int var4, boolean var3) {
            this.node = node;
            this.var4 = var4;
            this.var3 = var3;
        }
    }
}
