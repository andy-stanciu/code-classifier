class Solution {

    public int method1(int[][] param1) {
        Arrays.sort(param1, (a, b) -> {
            return a[0] - b[0];
        });
        int[] memoi = new int[param1.length];
        Arrays.fill(memoi, -1);
        return param1.length - dp(param1, 0, memoi);
    }

    private int dp(int[][] param1, int curr, int[] memoi) {
        // base case
        if (curr == param1.length) {
            return 1;
        }
        if (memoi[curr] != -1) {
            return memoi[curr];
        }
        // evaluate dp[curr + 1]
        int max = dp(param1, curr + 1, memoi);
        // take curr into count and find the next valid interval j for 1 + dp[j]
        int left = curr + 1, right = param1.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (isOverlapped(param1[curr], param1[mid])) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        // check if the next j is valid or not
        if (right != param1.length) {
            max = Math.max(max, 1 + dp(param1, right, memoi));
        }
        return memoi[curr] = max;
    }

    private boolean isOverlapped(int[] i1, int[] i2) {
        return i1[0] < i2[1] && i1[1] > i2[0];
    }
}
