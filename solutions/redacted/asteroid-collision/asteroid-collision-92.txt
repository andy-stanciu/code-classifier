class Solution {

    public int[] method1(int[] param1) {
        ArrayList<Integer> al = new ArrayList<>();
        Stack<Integer> sk = new Stack<>();
        for (int i = 0; i < param1.length; i++) {
            if (param1[i] > 0)
                sk.push(i);
            else {
                if (!sk.isEmpty() && Math.abs(param1[i]) < param1[sk.peek()]) {
                    continue;
                } else if (!sk.isEmpty() && Math.abs(param1[i]) == param1[sk.peek()])
                    sk.pop();
                else {
                    while (!sk.isEmpty() && Math.abs(param1[i]) > param1[sk.peek()]) {
                        sk.pop();
                    }
                    // breasking from while loop will have three cases
                    // 1st edge case when negative asteroid dominates
                    if (sk.isEmpty())
                        al.add(param1[i]);
                    // 2nd edge case when asteroid and sk.peek()is equal
                    if (!sk.isEmpty() && Math.abs(param1[i]) == param1[sk.peek()])
                        sk.pop();
                    // 3rd possiblity is of course when negatives asteroid is dominated
                }
            }
        }
        int index = al.size();
        while (!sk.isEmpty()) al.add(index, param1[sk.pop()]);
        return al.stream().mapToInt(i -> i).toArray();
    }
}
