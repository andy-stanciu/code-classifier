// recurrsive solution(tle)
// time complexity :: O(2^n)
// space complexity :: O(n) ;  for recurrsion stack space
// class Solution {
//     public int climbStairs(int n) {
//         if(n<=1) return 1;
//         return climbStairs(n-1) + climbStairs(n-2);
//     }
// }
// memoisation (top-bottom) solution
// time complexity :: O(n)
// space complexity :: O(n) + O(n) ; 1st for recurrsion stack space and 2nd for storing array
// class Solution {
//     public int helper(int n,int dp[]){
//         if(n<=1) return 1;
//         if(dp[n] != -1) return dp[n];
//         return dp[n] = helper(n-1,dp) + helper(n-2,dp);
//     }
//     public int climbStairs(int n) {
//         int dp[] = new int[n+1];
//         Arrays.fill(dp,-1);
//         return helper(n,dp);
//     }
// }
// // tabulation (bottom top) solution
// // time complexity :: O(n)
// // space complexity :: O(n); for storing array
// class Solution {
//     public int climbStairs(int n) {
//         if(n<=1) return 1;
//          int dp[] = new int[n+1];
//          dp[0] = 1;
//          dp[1] = 1;
//          for(int i = 2;i<=n;i++){
//             dp[i] = dp[i-1] + dp[i-2];
//          }
//          return dp[n];
//      }
// }
// // space optimisation
// // time complexity :: O(n)
// // space complexity :: O(1) ; storing two variables only
class Solution {

    public int method1(int n) {
        if (n <= 1)
            return 1;
        int prev = 1;
        int prevtoprev = 1;
        int curr = -1;
        for (int i = 2; i <= n; i++) {
            curr = prev + prevtoprev;
            prevtoprev = prev;
            prev = curr;
        }
        return curr;
    }
}
