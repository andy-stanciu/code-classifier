class Solution {

    public int method1(int[] nums) {
        // strategy: 2 pointers (both left-to-right; one slow and one fast)
        // slow pointer
        int idxIntoNums = 0;
        for (int n : nums) {
            // fast pointer
            // case 1: we\'re on the 1st or 2nd elements,
            //     so we can\'t look back 2 elements, but it\'s fine, because
            //     these elements will always be permissible
            if (idxIntoNums < 2) {
                nums[idxIntoNums++] = n;
                continue;
            }
            // case 2: we\'re on the 3rd and later element,
            //     so if the element 2 indices ago is not the current element,
            //     the current one is allowed, so we slot it into the next available
            //     index in `nums`
            if (n != nums[idxIntoNums - 2]) {
                nums[idxIntoNums++] = n;
                continue;
            }
        }
        // return that farthest that `idxIntoNums` got
        return idxIntoNums;
    }
}
