/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode method1(ListNode l1, ListNode l2) {
        if (l1 == null && l2 == null)
            return null;
        if (l1 == null || l2 == null)
            return l1 == null ? l2 : l1;
        // these two stacks will store the nodes of the l1 and l2 respectively
        Stack<ListNode> stack_1 = new Stack<>();
        Stack<ListNode> stack_2 = new Stack<>();
        // this will store the digits for our resultant list
        Stack<Integer> result = new Stack<>();
        // temporary heads
        ListNode h1 = l1, h2 = l2;
        while (h1 != null) {
            stack_1.push(h1);
            if (h1.next == null)
                break;
            h1 = h1.next;
        }
        while (h2 != null) {
            stack_2.push(h2);
            if (h2.next == null)
                break;
            h2 = h2.next;
        }
        int carry = 0;
        // the preHead is a dummy node we will use to track the head of our
        // resultant list, curr will be used to add nodes to the list
        ListNode preHead = new ListNode();
        ListNode curr = preHead;
        while (!stack_1.isEmpty() && !stack_2.isEmpty()) {
            int node1 = stack_1.pop().val;
            int node2 = stack_2.pop().val;
            int val = node1 + node2 + carry;
            if (val >= 10) {
                carry = val / 10;
                val = val % 10;
            } else
                carry = 0;
            result.push(val);
        }
        /* if one of the list get exhausted then we will have other   list to traverse
        */
        while (!stack_1.isEmpty()) {
            int node1 = stack_1.pop().val;
            int val = node1 + carry;
            if (val >= 10) {
                carry = val / 10;
                val = val % 10;
            } else
                carry = 0;
            result.push(val);
        }
        while (!stack_2.isEmpty()) {
            int node2 = stack_2.pop().val;
            int val = node2 + carry;
            if (val >= 10) {
                carry = val / 10;
                val = val % 10;
            } else
                carry = 0;
            result.push(val);
        }
        // if any carry is still there
        if (carry > 0) {
            result.push(carry);
        }
        // now we make our list
        while (!result.isEmpty()) {
            ListNode node = new ListNode(result.pop());
            curr.next = node;
            curr = node;
        }
        return preHead.next;
    }
}
