/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode method1(ListNode[] param1) {
        PriorityQueue<ListNode> pq = new PriorityQueue<ListNode>(new Comparator<ListNode>() {

            public int compare(ListNode h1, ListNode h2) {
                return h1.val - h2.val;
            }
        });
        for (ListNode i : param1) {
            if (i != null) {
                pq.add(i);
            }
        }
        ListNode ans = new ListNode(-1);
        ListNode curr = ans;
        while (!pq.isEmpty()) {
            ListNode temp = pq.poll();
            curr.next = temp;
            curr = curr.next;
            if (temp.next != null) {
                pq.add(temp.next);
            }
        }
        return ans.next;
    }
}
// Approach - 1 - Intuitive Approach
// public ListNode mergeKLists(ListNode[] lists) {
// if (lists == null || lists.length == 0) {
// return null;
// }
// ListNode h0 = lists[0];
// ListNode ans = null;
// for(int i = 1; i< lists.length; i++){
// ListNode l1 = lists[i];
// ans = mergeFunction(h0, l1);
// h0 = ans;
// }
// if(ans!=null){
// return ans;
// }
// else{
// return h0;
// }
// }
// public ListNode mergeFunction(ListNode x, ListNode y){
// ListNode dummy = new ListNode();
// ListNode ans1 = dummy;
// while(x != null && y!=null){
// if(x.val > y.val){
// dummy.next = y;
// y = y.next;
// }
// else{
// dummy.next = x;
// x = x.next;
// }
// dummy = dummy.next;
// }
// if (x!= null) dummy.next = x;
// else dummy.next = y;
// return ans1.next;
// }
