class Solution {

    public List<List<Integer>> combine(int n, int k) {
        // Create a list to store the current combination being formed
        List<Integer> curr_combination = new ArrayList<>();
        // Create a list to store all the valid combinations
        List<List<Integer>> result = new ArrayList<>();
        // Call the backtrack function to generate all combinations
        backtrack(n, k, 1, curr_combination, result);
        // Return the final list of combinations
        return result;
    }

    public void backtrack(int n, int k, int start, List<Integer> curr_combination, List<List<Integer>> result) {
        // Check if the current combination is of size k
        if (curr_combination.size() == k) {
            // If the size is k, add a copy of the current combination to the result list
            result.add(new ArrayList<>(curr_combination));
            return;
        }
        // Loop through all possible numbers from start to n
        for (int i = start; i <= n; i++) {
            // Add the current number to the current combination
            curr_combination.add(i);
            // Recursively call the backtrack function with the updated start and current combination
            backtrack(n, k, i + 1, curr_combination, result);
            // After the recursion, remove the last added number to try the next number in the loop
            curr_combination.remove(curr_combination.size() - 1);
        }
    }
}
