class Solution {

    public List<List<Integer>> combine(int n, int k) {
        // Use set to ensure no duplicate values are added to result set
        Set<List<Integer>> set = new HashSet<>();
        // Start the backtracking from 1 to n
        for (int i = 1; i <= n; i++) {
            backtrack(i, n, k, new ArrayList<>(), set);
        }
        return new ArrayList<>(set);
    }

    private void backtrack(int currentNumber, int n, int k, List<Integer> list, Set<List<Integer>> set) {
        // If the size of local list is greater than k then we will not do anything.
        if (list.size() > k) {
            return;
        }
        // Add the current number to list.
        list.add(currentNumber);
        // If the size of list is equal to k then we add the list to the result set.
        if (list.size() == k)
            set.add(new ArrayList<>(list));
        for (int i = currentNumber + 1; i <= n; i++) {
            // Increment currentNumber by 1 to get all the possible combinations
            backtrack(i, n, k, list, set);
        }
        list.remove(list.size() - 1);
    }
}
