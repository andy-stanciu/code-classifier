class Solution {

    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        List<Integer> op = new ArrayList<>();
        List<Integer> ip = new ArrayList<>();
        for (int i = 1; i <= n; i++) ip.add(i);
        solve(op, ip, k);
        return res;
    }

    void solve(List<Integer> op, List<Integer> ip, int k) {
        if (op.size() == k) {
            res.add(op);
            return;
        }
        if (ip.size() == 0)
            return;
        if (// works without this condition but increases time complexity
        ip.size() + op.size() < k)
            return;
        List<Integer> clone = new ArrayList<>(ip);
        List<Integer> op1 = new ArrayList<>(op);
        op1.add(clone.get(0));
        clone.remove(0);
        solve(op, clone, k);
        solve(op1, clone, k);
    }
}
