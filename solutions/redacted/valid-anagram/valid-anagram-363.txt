class Solution {

    public boolean method1(String s, String t) {
        // //Approch 1: Using Single HashMap: TimeComplexity O(2n), Space Complexity: O(n)
        // if(s.length() != t.length()) return false;
        // Map<Character, Integer> map = new HashMap<>();
        // for(int i=0; i<s.length(); i++){
        //     map.put(s.charAt(i), map.getOrDefault(s.charAt(i),0) +1);
        // }
        // for(int j=0; j<t.length(); j++){
        //     map.put(t.charAt(j), map.getOrDefault(t.charAt(j), 0)-1);
        //     if(map.get(t.charAt(j))==0) {
        //         map.remove(t.charAt(j));
        //     }
        // }
        // return map.isEmpty()? true: false;
        ////Approch 2: Using character array:
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        Arrays.sort(sArr);
        Arrays.sort(tArr);
        String stringS = String.valueOf(sArr);
        String stringT = String.valueOf(tArr);
        return stringS.equals(stringT);
        //// Note: Question tweaked a bit we need to return true if string s and string t contains
        //// same character with any character frequency>
        ////Which means both string should have same set of character in them no matter the
        //// repeatation of each of the character.
        // //Approch 2: Using Single set: TimeComplexity O(2n), Space Complexity: O(n)
        // Set<Character> set = new HashSet<>();
        // String large;
        // String small;
        // if(s.length() <= t.length()){
        //     small = s;
        //     large = t;
        // }
        // else{
        //     small = t;
        //     large =s;
        // }
        // for(int i=0; i<large.length(); i++){
        //     if(set.add(large.charAt(i)));
        // }
        // for(int j=0; j<small.length(); j++){
        //     if(set.contains(small.charAt(j))){
        //         set.remove(small.charAt(j));
        //     }
        // }
        // return set.isEmpty()? true: false;
    }
}
