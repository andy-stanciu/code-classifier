class Solution {

    public int method1(int[][] points) {
        int n = points.length;
        Arrays.sort(points, Comparator.comparingInt(a -> a[0]));
        int[] prev = points[0];
        int count = 1;
        for (int i = 1; i < n; i++) {
            int currStartPoint = points[i][0];
            int currEndPoint = points[i][1];
            int prevStartPoint = prev[0];
            int prevEndPoint = prev[1];
            if (currStartPoint > prevEndPoint) {
                // no overlap
                count++;
                prev = points[i];
            } else {
                // overlap
                prev[0] = Math.max(prevStartPoint, currStartPoint);
                prev[1] = Math.min(prevEndPoint, currEndPoint);
            }
        }
        return count;
    }
}
// class Solution {
//     public int findMinArrowShots(int[][] points) {
//         int n = points.length;
//         int i=1;
//         Arrays.sort(points, Comparator.comparingInt(row -> row[0]));
//         int prev[]= points[0];
//         int arrow =1;
//         while(i < n){
//             int CurSp = points[i][0];
//             int CurrEndp = points[i][1];
//             int prevSp =prev[0];
//             int prevEndp =prev[1];
//             if(CurSp > prevEndp){
//                 arrow++;
//                prev = points[i];
//             }else{
//                 prev[0] = Math.max(prevSp,CurSp);
//                 prev[1] = Math.min(prevSp,CurrEndp);
//             }
//             i++;
//         }
//         return arrow;
//     }
// }
