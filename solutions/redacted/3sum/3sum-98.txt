/*approach:-
 1.Brute froce :-intially we brute force using 3 for loops (for i=0 -> n-1 )& (forj=i+1->n-1)& 
   for(k=j+1->n-1) which will anyways give the TLE. 
   
    TC:->(n3 * log m).
   
   
 2.Better solution Using Hashmap and set:-  a+b+c=0 this is the case so we can say c= -(a+b)  which        indirect give the triplet we need and we will addd the triplet to set to get unique triplets, we        intially get frequency of all values and store it in hashmap and we check if -(a[i]+a[j]) in our         hashmap then we consider it as a valid triplet and add it to set.
 
    TC->O(n2 * log m).
    
 3.Optimal is using two pointer approach:- as a+b+c=0 then we can do a+b=-c makes it simple it comes to     the same 2 sum approach we just consider each number in list by sorting it and initialize two           pointers from the next number and last and do two sum approach and we consider the elements which
    not previously used which makes to catch unique triplets by default without any set 
    
    TC:-> O(n*n)
   
*/
class Solution {

    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++) {
            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
                int low = i + 1, high = nums.length - 1, sum = 0 - nums[i];
                while (low < high) {
                    if (nums[low] + nums[high] == sum) {
                        result.add(Arrays.asList(nums[i], nums[low], nums[high]));
                        while (low < high && nums[low] == nums[low + 1]) low++;
                        while (low < high && nums[high] == nums[high - 1]) high--;
                        low++;
                        high--;
                    } else if (nums[low] + nums[high] < sum) {
                        low++;
                    } else {
                        high--;
                    }
                }
            }
        }
        return result;
    }
}
