class Solution {

    //Recurssion
    // public int coinChange(int[] coins, int k) {
    //     int ans= f(coins, coins.length-1, k);
    //     if(ans >= (int)1e9) return -1;  // this is to handle a edge case, like if there are no possible ways so the problem must return -1
    //     else return ans;
    // }
    // public int f(int[] nums, int ind, int k){
    //     if(ind == 0){
    //        if(k % nums[ind] == 0){ // if remainder is 0 then we have to take total k / nums[ind] coins to form k, eg: 8/2 = 4 coins required
    //            return k/nums[ind];
    //        }else{
    //            return (int)1e9; // if remainder is not 0 then we cant form the kth calue with nums[ind] so return Max number to avoid nums[ind]
    //        }
    //     }
    //     int take= (int)1e9;
    //     if(nums[ind] <= k){
    //         take= 1 + f(nums, ind, k-nums[ind]);
    //     }
    //     int notTake= 0 + f(nums, ind-1, k);
    //     return Math.min(take, notTake);
    // }
    //Memoization
    // public int coinChange(int[] coins, int k) {
    //     int[][] dp= new int[coins.length][k+1];
    //     for(int[] row : dp){
    //         Arrays.fill(row,-1);
    //     }
    //     int ans= f(coins, coins.length-1, k, dp);
    //     if(ans >= (int)1e9) return -1;  // this is to handle a edge case, like if there are no possible ways so the problem must return -1
    //     else return ans;
    // }
    // public int f(int[] nums, int ind, int k, int[][] dp){
    //     if(ind == 0){
    //        if(k % nums[ind] == 0){
    //            return k/nums[ind];
    //        }else{
    //            return (int)1e9;
    //        }
    //     }
    //     if(dp[ind][k] != -1) return dp[ind][k];
    //     int take= (int)1e9;
    //     if(nums[ind] <= k){
    //         take= 1 + f(nums, ind, k-nums[ind], dp);
    //     }
    //     int notTake= 0 + f(nums, ind-1, k, dp);
    //     return dp[ind][k]= Math.min(take, notTake);
    // }
    //Tabulation
    public int method1(int[] nums, int k) {
        int[][] dp = new int[nums.length][k + 1];
        for (int i = 0; i <= k; i++) {
            // base case
            if (i % nums[0] == 0) {
                dp[0][i] = i / nums[0];
            } else {
                dp[0][i] = (int) 1e9;
            }
        }
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= k; j++) {
                int take = (int) 1e9;
                if (nums[i] <= j) {
                    take = 1 + dp[i][j - nums[i]];
                }
                int notTake = 0 + dp[i - 1][j];
                dp[i][j] = Math.min(take, notTake);
            }
        }
        int ans = dp[nums.length - 1][k];
        if (ans >= (int) 1e9)
            return -1;
        else
            return ans;
    }
}
