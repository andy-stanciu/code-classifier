class Solution {

    public int lengthOfLIS(int[] nums) {
        // Initialize an array `t` to store the length of the longest increasing subsequence (LIS)
        // ending at each index of the `nums` array.
        // Initially, all values in `t` are 0 because we haven\'t computed the LIS lengths yet.
        int[] t = new int[nums.length];
        // Outer loop goes through each element in `nums` starting from index 1 to the end.
        for (int i = 1; i < nums.length; i++) {
            // Inner loop goes through each element before the current element `i`.
            for (int j = 0; j < i; j++) {
                // If the current element `nums[i]` is greater than the previous element `nums[j]`,
                // it means we can extend the subsequence ending at `j` to include the element at `i`.
                if (nums[i] > nums[j]) {
                    // Update the LIS length at index `i` by comparing the current LIS length at `i`
                    // (`t[i]`) with the LIS length at `j` plus one (`t[j] + 1`).
                    if (t[j] + 1 > t[i]) {
                        t[i] = t[j] + 1;
                    }
                }
            }
        }
        // Now, we need to find the maximum value in the `t` array, which represents the
        // longest increasing subsequence length across all possible ending points.
        // Initialize a variable to track the index with the maximum LIS length.
        int maxidx = 0;
        // Iterate through the `t` array to find the maximum LIS length.
        for (int i = 0; i < t.length; i++) {
            if (t[i] > t[maxidx]) {
                // Update `maxidx` to the index of the new maximum LIS length.
                maxidx = i;
            }
        }
        // Return the maximum LIS length found, adding 1 because `t` starts from 0 (so length needs +1).
        return t[maxidx] + 1;
    }
}
