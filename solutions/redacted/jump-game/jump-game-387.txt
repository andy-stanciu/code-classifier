class Solution {

    /**
     *    Idea is. to use greedy method and go from end to start
     *    We need to reach last element that is nums.length - 1
     *    So we keep checking which all numbers can take us to this last eelement goal
     *    If a number can take you to the goal, we mark current number index as new goal
     *    and we keep on shifting goal post towards left.
     *    If we reach all the way to the start, that is 0, then we can say jump can go all
     *    the way till last number.
     */
    public boolean method1(int[] nums) {
        // Greedy soln
        int endGoal = nums.length - 1;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (i + nums[i] >= endGoal) {
                endGoal = i;
            }
        }
        return endGoal == 0;
        // DP Based solution
        /**
         *        int n = nums.length;
         *        boolean[] dp = new boolean[n];
         *        dp[n - 1] = true;
         *        for (int i = n - 2; i >= 0; i--) {
         *            for (int k = nums[i]; k >= 1; k --) {
         *                int jumpPost = i + k;
         *                if (i + k >= n - 1 || dp[i + k]) {
         *                    dp[i] = true;
         *                    break;
         *                }
         *            }
         *        }
         *
         *        return dp[0];
         */
    }
}
