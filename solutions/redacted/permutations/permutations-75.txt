class Solution {

    //The result array that will be returned
    List<List<Integer>> result = new ArrayList<>();

    //This is our temp List that is dynamic from time to time
    List<Integer> temp = new ArrayList<>();

    // I declared this as a global variable to avoid passing the nums array given into our recursive function
    int[] nums;

    // Length of the given array
    int n;

    public List<List<Integer>> permute(int[] nums) {
        // Assigning the nums array given to the global variable above
        this.nums = nums;
        // Assigning length of array to n
        n = nums.length;
        // Calling the recursive function now
        recur();
        return result;
    }

    //This is the recursive  function
    void recur() {
        if (temp.size() == n) {
            // Our Base Case
            //Adding found permutation to our result List
            result.add(new ArrayList<>(temp));
            return;
        }
        for (int i = 0; i < n; i++) {
            // Iterating over each element in the nums array
            if (// Now, if temp List already contains this element, we simply skip and continue the loop
            temp.contains(nums[i]))
                continue;
            //Otherwise, we add to tempList
            temp.add(nums[i]);
            // and then, we call our recursive function again
            recur();
            // Once, we return from the last recursion, it simply means we just found a permutation;
            temp.remove(temp.size() - 1);
            //thus, we have to remove the last element added to the tempList
            //so that we can have the last last tempList befor this last recursion we  just returned from.
            //Hope you grab now.
        }
    }
}
