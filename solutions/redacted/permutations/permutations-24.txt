class Solution {

    public List<List<Integer>> permute(int[] arr) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> tempAns = new ArrayList<>();
        // taking this to check which index is picked
        boolean[] check = new boolean[arr.length];
        return f(arr, tempAns, ans, check);
    }

    public List<List<Integer>> f(int[] arr, List<Integer> tempAns, List<List<Integer>> ans, boolean[] check) {
        if (tempAns.size() == arr.length) {
            ans.add(new ArrayList<>(tempAns));
            return ans;
        }
        for (int i = 0; i < arr.length; i++) {
            // traversing ech index one by one
            if (!check[i]) {
                // if not picked then picked
                // add ele in tempAns
                tempAns.add(arr[i]);
                // updated the index as picked
                check[i] = true;
                // recc call
                f(arr, tempAns, ans, check);
                // while returning remove the last ele so that it would not be picked next time for
                tempAns.remove(tempAns.size() - 1);
                check[i] = false;
            }
        }
        return ans;
    }
    // Reccursive tree
    //                         []
    //                 /         |        \\
    //          [1]          [2]        [3]
    //          / \\         /  \\       /   \\
    //     [1,2] [1,3]  [2,1] [2,3]  [3,1] [3,2]
    //    /   \\      |       |        |       |
    // [1,2,3] [1,3,2]  [2,1,3]  [2,3,1] [3,1,2] [3,2,1]
}
