class Solution {

    public int method1(int[] nums, int k) {
        // \uBC30\uC5F4 -> \uB9AC\uC2A4\uD2B8
        List<Integer> numList = Arrays.stream(nums).boxed().collect(Collectors.toList());
        // \uCD5C\uB300 \uD799 \uC815\uC758
        // \uC774\uB54C, Comparator \uBC0F Collection\uC744 \uBAA8\uB450 \uBC1B\uB294 \uC0DD\uC131\uC790\uB294 \uC5C6\uC73C\uBBC0\uB85C, PriorityQueue(int initialCapacity, Comparator<? super E> comparator) \uC774\uC6A9
        PriorityQueue<Integer> maxHeap = new PriorityQueue(numList.size(), Collections.reverseOrder());
        // \uB9AC\uC2A4\uD2B8\uC758 \uC694\uC18C\uB4E4\uC744 \uCD5C\uB300 \uD799\uC5D0 \uCD94\uAC00
        maxHeap.addAll(numList);
        // k\uBC88\uC9F8 \uAC12\uC744 \uAEBC\uB0B4\uAE30
        // \uB2E8, Priority Queue\uC5D0\uC11C\uB294 .get(E e)\uB97C \uC9C0\uC6D0\uD558\uC9C0 \uC54A\uC73C\uBBC0\uB85C, .remove() + .peek() \uC870\uD569\uC73C\uB85C \uAC12\uC744 \uAC00\uC838\uC624\uAE30
        int size = maxHeap.size();
        // Iterator\uB97C \uC0AC\uC6A9\uD560 \uACBD\uC6B0, \uB3D9\uC2DC\uC131 \uC774\uC288\uAC00 \uBC1C\uC0DD\uD558\uBBC0\uB85C basic for \uC0AC\uC6A9
        // one-based index\uC774\uBBC0\uB85C 1\uBD80\uD130 \uC2DC\uC791 && k\uBC88\uC9F8 \uAC12\uC744 \uAEBC\uB0B4\uC57C\uD558\uBBC0\uB85C k\uBC88\uC9F8 \uC804\uAE4C\uC9C0 \uC21C\uD68C
        for (int i = 1; i < k; i++) {
            maxHeap.poll();
        }
        return maxHeap.peek();
    }
}
