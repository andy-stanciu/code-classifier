class Solution {

    int maxRow, maxCol;

    int[][] obstacleGrid;

    // Directions array to explore right and down cells
    int[][] directions = new int[][] { { 0, 1 }, { 1, 0 } };

    // Memoization matrix
    int[][] memo;

    public int method1(int[][] obstacleGrid) {
        this.obstacleGrid = obstacleGrid;
        maxRow = obstacleGrid.length;
        maxCol = obstacleGrid[0].length;
        // If start or end cell is an obstacle, return 0
        if (obstacleGrid[0][0] == 1 || obstacleGrid[maxRow - 1][maxCol - 1] == 1)
            return 0;
        // Initialize memoization matrix with -1
        memo = new int[maxRow][maxCol];
        for (int[] arr : memo) Arrays.fill(arr, -1);
        // Start dynamic programming from the top-left cell
        return dp(0, 0);
    }

    public int dp(int currRow, int currCol) {
        // If we reach the destination cell, there is one unique path
        if (currRow == maxRow - 1 && currCol == maxCol - 1)
            return 1;
        // If this cell is already computed, return the stored value
        if (memo[currRow][currCol] != -1)
            return memo[currRow][currCol];
        int answer = 0;
        // Explore right and down cells
        for (int[] direction : directions) {
            int nextRow = currRow + direction[0];
            int nextCol = currCol + direction[1];
            // If the next cell is valid (within grid and not an obstacle), add its unique paths to the answer
            if (isValid(nextRow, nextCol)) {
                answer += dp(nextRow, nextCol);
            }
        }
        // Store the computed unique paths for this cell
        memo[currRow][currCol] = answer;
        return answer;
    }

    // Check if a cell is valid (within grid and not an obstacle)
    public boolean isValid(int row, int col) {
        return 0 <= row && 0 <= col && row < maxRow && col < maxCol && obstacleGrid[row][col] != 1;
    }
}
