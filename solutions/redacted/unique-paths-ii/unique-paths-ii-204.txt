class Solution {

    /*
        dynamic programming:
        let UniquePath(i, j) be the number of unique paths to reach (i, j) from (0, 0) by only moving down or right

        to reach (i, j), we either go down from (i-1, j) or go right from (i, j-1)
        UniquePath(i, j) =
                     - case 1: UniquePath(i-1, j) + UniquePath(i, j-1), if obstacleGrid[i][j] == 0
                     - case 2: 0                                      , if obstacleGrid[i][j] == 1

        base cases:
        UniquePath(0, x) =
                    - case 1: UniquePath(0, x-1), if obstacleGrid[0][x] == 0
                    - case 2: 0, otherwise

        UniquePath(x, 0) =
                    - case 1: UniquePath(x-1, 0), if obstacleGrid[x][0] == 0
                    - case 2: 0, otherwise

        UniquePath(0, 0) = 1 if obstacleGrid[0][0] == 0, 0 otherwise
    */
    public int method1(int[][] obstacleGrid) {
        // edge cases
        int m = obstacleGrid.length;
        if (m == 0) {
            return 1;
        }
        int n = obstacleGrid[0].length;
        if (n == 0) {
            return 1;
        }
        int[][] var1 = new int[m][n];
        // base cases
        var1[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 1; i < m; i++) {
            var1[i][0] = obstacleGrid[i][0] == 0 ? var1[i - 1][0] : 0;
        }
        for (int j = 1; j < n; j++) {
            var1[0][j] = obstacleGrid[0][j] == 0 ? var1[0][j - 1] : 0;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 0) {
                    // case 1
                    var1[i][j] = var1[i - 1][j] + var1[i][j - 1];
                } else {
                    // case 2
                    var1[i][j] = 0;
                }
            }
        }
        return var1[m - 1][n - 1];
    }
}
