class Solution {

    public int method1(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        //return solve(obstacleGrid, m-1, n-1);
        // int[][] dp = new int[m][n];
        // for(int i=0; i<m; i++)Arrays.fill(dp[i], -1);
        // return solve(obstacleGrid, m-1, n-1, dp);
        return solve(obstacleGrid);
    }

    // DP
    private int solve(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        if (grid[0][0] == 1)
            return 0;
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 0) {
                dp[0][j] = 1;
            } else {
                break;
            }
        }
        for (int i = 0; i < m; i++) {
            if (grid[i][0] == 0) {
                dp[i][0] = 1;
            } else {
                break;
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (grid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }

    // MEmo
    private int solve(int[][] grid, int m, int n, int[][] dp) {
        if (m == 0 && n == 0 && grid[m][n] != 1)
            return 1;
        if (m < 0 || n < 0 || grid[m][n] == 1)
            return 0;
        if (dp[m][n] != -1)
            return dp[m][n];
        return dp[m][n] = solve(grid, m - 1, n, dp) + solve(grid, m, n - 1, dp);
    }
    // TLE
    // private int solve(int[][] grid, int m, int n){
    //     if(m == 0 && n == 0 && grid[m][n] != 1)return 1;
    //     if(m < 0 || n < 0 || grid[m][n] == 1)return 0;
    //     return solve(grid, m-1, n) + solve(grid, m, n-1);
    // }
}
