class Solution {

    public int method1(int[][] obstacleGrid) {
        // Get the dimensions of the grid
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        // Start the recursive function to calculate unique paths
        return helper(obstacleGrid, m - 1, n - 1);
    }

    public int helper(int[][] grid, int row, int col) {
        // If out of bounds, return 0 as there are no valid paths
        if (row < 0 || col < 0)
            return 0;
        // If there\'s an obstacle at the current cell, return 0 paths
        if (grid[row][col] == 1)
            return 0;
        // If we reach the starting cell (0, 0), return 1 path
        if (row == 0 && col == 0)
            return 1;
        // Calculate paths from the left and the top cells
        // Moving left
        int left = helper(grid, row, col - 1);
        // Moving up
        int up = helper(grid, row - 1, col);
        // Return the total number of unique paths from both directions
        return left + up;
    }
}
/*
Time Complexity: O(2^(m + n))
- Without memoization, each recursive call branches into two further calls, leading to an exponential time complexity.
- For large grid sizes, this approach will be very slow.

Space Complexity: O(m + n)
- The maximum depth of the recursion stack is m + n in the worst case.
*/
