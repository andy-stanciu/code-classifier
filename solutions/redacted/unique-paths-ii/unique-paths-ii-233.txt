class Solution {

    public int method1(int[][] dp) {
        //if destination contains obstacle then return 0 as there are zero ways to reach destination.
        if (dp[dp.length - 1][dp[0].length - 1] == 1) {
            return 0;
        }
        //if start contains obstacle then return 0 as there are zero ways to reach destination.
        if (dp[0][0] == 1) {
            return 0;
        }
        //Convert all the obstacles from 1 to -1
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                if (dp[i][j] == 1) {
                    dp[i][j] = -1;
                }
            }
        }
        //initialize start to 1 as their is one way to reach start
        dp[0][0] = 1;
        //First Row and First Column are the base case because->
        // 1)-> as there is only way to reach each element of first row from left.
        // 2)-> as there is only way to reach each element of first column from up.
        //Initialize each element of first row to 1 as there is only way to reach from left.
        for (int i = 1; i < dp[0].length; i++) {
            //if left element does not contain obstacle(that is -1) and current element is not obstacle
            // (that is -1). then initialize it to 1 as there is only 1 way
            if (dp[0][i - 1] == -1 || dp[0][i] == -1) {
                dp[0][i] = -1;
            } else {
                dp[0][i] = 1;
            }
        }
        for (int i = 1; i < dp.length; i++) {
            //if upward element does not contain obstacle(that is -1) and current element is not obstacle
            // (that is -1). then initialize it to 1 as there is only 1 way
            if (dp[i - 1][0] == -1 || dp[i][0] == -1) {
                dp[i][0] = -1;
            } else {
                dp[i][0] = 1;
            }
        }
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                //if upward element does not contain obstacle(that is -1) and current element is not obstacle
                // (that is -1). then add the number of ways to reach upward element(i-1,j) in current element(i,j).
                if (dp[i - 1][j] != -1 && dp[i][j] != -1) {
                    dp[i][j] += dp[i - 1][j];
                }
                //if left element does not contain obstacle(that is -1) and current element is not obstacle
                // (that is -1).  then add the number of ways to reach left element(i,j-1) in current element(i,j).
                if (dp[i][j - 1] != -1 && dp[i][j] != -1) {
                    dp[i][j] += dp[i][j - 1];
                }
            }
        }
        //return the number of ways to reach destination(i=dp.length-1,j=dp[0].length-1)
        return dp[dp.length - 1][dp[0].length - 1];
    }
}
