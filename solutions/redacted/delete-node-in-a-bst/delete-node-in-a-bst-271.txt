/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    TreeNode root;

    public TreeNode method1(TreeNode root, int key) {
        this.root = root;
        TreeNode var1 = search(root, key);
        if (var1 != null) {
            method2(var1);
        }
        return this.root;
    }

    private void method2(TreeNode param1) {
        if (param1.left == null) {
            // node has no left child, then replace node with it\'s right child which may or may not be null
            transplant(param1, param1.right);
        } else if (param1.right == null) {
            // node has no right child, but has one child which is the left child
            transplant(param1, param1.left);
        } else {
            // node has both left and right child, find node\'s successor
            TreeNode successor = method3(param1.right);
            // if successor is further down the tree (in which case it is not directly the right child of node to be deleted)
            if (successor != param1.right) {
                // replace successor by it\'s right child (Because it cannot have a left child)
                transplant(successor, successor.right);
                successor.right = param1.right;
            }
            // replace node by it\'s successor
            transplant(param1, successor);
            successor.left = param1.left;
        }
    }

    // find the minimum element in the subree rooted at the given node
    private TreeNode method3(TreeNode param1) {
        if (param1.left != null) {
            return method3(param1.left);
        }
        return param1;
    }

    private TreeNode search(TreeNode param1, int key) {
        if (param1 == null || param1.val == key) {
            return param1;
        }
        if (key > param1.val) {
            return search(param1.right, key);
        } else {
            return search(param1.left, key);
        }
    }

    // search for the parent of a node
    private TreeNode parentSearch(TreeNode param1) {
        if (param1 == root) {
            return null;
        }
        TreeNode parent = root;
        TreeNode current;
        if (parent.val > param1.val) {
            current = parent.left;
        } else {
            current = parent.right;
        }
        return recursiveParentSearch(parent, current, param1.val);
    }

    // recursive helper method to search for paren of a node
    private TreeNode recursiveParentSearch(TreeNode parent, TreeNode current, int key) {
        if (current.val == key) {
            return parent;
        }
        parent = current;
        if (current.val > key) {
            return recursiveParentSearch(parent, current.left, key);
        } else {
            return recursiveParentSearch(parent, current.right, key);
        }
    }

    // method replaces one subtree as a child of it\'s parent with another subtree
    private void transplant(TreeNode u, TreeNode v) {
        TreeNode parentOfU = parentSearch(u);
        if (parentOfU == null) {
            root = v;
        } else if (u == parentOfU.left) {
            parentOfU.left = v;
        } else {
            parentOfU.right = v;
        }
    }
}
