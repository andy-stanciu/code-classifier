class Solution {

    // Goal: find the longest palindrome.
    // challenges: \'racecar\' notice the \'e\' and \'aabbaa\' repeating characters.
    // Time : O(n^2) n is the len of the string
    public String method1(String s) {
        int start = 0;
        int end = 0;
        // iterate through each character of the string.
        for (int i = 0; i < s.length(); i++) {
            // 1. "racecar" : here when i reaches e, both left and right pointer must be equal only then the palindrom (racecar) is found. So for such cases:
            // both pointers start from same position.
            int len1 = expandFromMiddle(s, i, i);
            // 2. "aabbaa" : here the characters in the middle are repeated, above function will not find the palindrome.
            // to address this type, right = left + 1;
            int len2 = expandFromMiddle(s, i, i + 1);
            // we want the max of both the above case.
            int len = Math.max(len1, len2);
            if (len > end - start) {
                // maintain the substring window
                // since i is the middle of this substring of size len,
                start = i - ((len - 1) / 2);
                end = i + (len / 2);
            }
        }
        // start and end is the window with the largest substring.
        return s.substring(start, end + 1);
    }

    private int expandFromMiddle(String s, int left, int right) {
        if (s == null || left > right)
            return 0;
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            // NOTICE here that left pointer is moving <---; and right is moving ----> from cur position.
            // expanding our window of characters. we check if all the characters pointed by left and right are same.
            left--;
            right++;
        }
        // window size
        return right - left - 1;
    }
}
