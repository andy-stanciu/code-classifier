class Solution {

    public String method1(String s) {
        /* Approach 2  */
        if (s == null || s.isEmpty())
            return "";
        int l = 0, r = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = checkHighestPalindrome(s, i, i);
            int len2 = checkHighestPalindrome(s, i, i + 1);
            int max_L = Math.max(len1, len2);
            if (max_L > r - l) {
                // window size r-l
                l = i - (max_L - 1) / 2;
                r = i + max_L / 2;
            }
        }
        return s.substring(l, r + 1);
        /* App1
        if (s == null || s.length() < 1) return "";
    
    int start = 0;
    int maxLength = 1;
    
    int n = s.length();
    boolean[][] dp = new boolean[n][n];

    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }

    for (int i = 0; i < n - 1; i++) {
        if (s.charAt(i) == s.charAt(i + 1)) {
            dp[i][i + 1] = true;
            start = i;
            maxLength = 2;
        }
    }

    for (int len = 3; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                if (len > maxLength) {
                    start = i;
                    maxLength = len;
                }
            }
        }
    }
    
    return s.substring(start, start + maxLength);

    */
    }

    // t checks characters on both sides and expands
    // as long as they are equal and within bounds.
    private static int checkHighestPalindrome(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
