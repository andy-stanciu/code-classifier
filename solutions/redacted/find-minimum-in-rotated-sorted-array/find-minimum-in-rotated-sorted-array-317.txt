class Solution {

    public int method1(int[] nums) {
        // here we have a left sorted sub-array and right sorted sub-array and there is a pivot point thats the min of the array
        // we need binary search to achieve O(logn).
        // so always the right sorted array is going to be smaller then left sorted sub-array because it is rotated to the right
        // the min is the first element of the right sorted sub-array
        // from min val, left val and right val will both increase, it is the pivot
        // to find pivot, we check if mid is part of left array or right array. so if nums[mid]>nums[l] -> left array, we got to get to right array to find min
        // if nums[mid]>=nums[l], then to get to right array (where pivot/minumum is) we set l=mid+1
        int l = 0;
        int r = nums.length - 1;
        int res = nums[0];
        while (l <= r) {
            // if we are in left or right array, then nums[l] must be less than nums[r]
            if (nums[l] < nums[r]) {
                res = Math.min(res, nums[l]);
            }
            // classic binary search mid
            int mid = (l + r) / 2;
            // update res val
            res = Math.min(res, nums[mid]);
            if (nums[mid] >= nums[l]) {
                // we go to right sub-array
                l = mid + 1;
            } else if (nums[mid] < nums[l]) {
                // we dont know if we are in the start of right array or not
                r = mid - 1;
            }
        }
        return res;
    }
}
