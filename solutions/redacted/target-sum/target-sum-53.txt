class Solution {

    public int method1(int[] nums, int param1) {
        // break array into 2 different arrays with sums s1, s2
        // such that s1-s2=target (all +ve in one array, all -ve in other)
        // as s1+s2=totalSum
        // => s2= (totalSum-target)/2
        // find no of subarrays whose sum is (total-target/2)
        int total = 0, zc = 0;
        for (int i : nums) {
            total += i;
            if (i == 0)
                zc++;
        }
        if (total - param1 < 0 || (total - param1) % 2 != 0)
            return 0;
        int actual = (total - param1) / 2;
        int n = nums.length;
        int[][] dp = new int[n + 1][actual + 1];
        //dp[0][t] => 0 elements are contributing to target t
        //dp[1][t] => 1 element(1st element arr[0])contributes to target t
        //dp[i] => until arr[i-1] (1 based indexing in dp) to 0 based indexing in arr
        int mod = 1000000007;
        for (int i = 0; i <= n; i++) {
            //any number of elements can contribute to target=0
            dp[i][0] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int t = 0; t <= actual; t++) {
                //exclude case
                dp[i][t] = dp[i - 1][t];
                if (nums[i - 1] != 0 && t >= nums[i - 1]) {
                    dp[i][t] += dp[i - 1][t - nums[i - 1]];
                }
            }
        }
        return (int) (dp[n][actual] * Math.pow(2, zc) % mod);
    }
}
