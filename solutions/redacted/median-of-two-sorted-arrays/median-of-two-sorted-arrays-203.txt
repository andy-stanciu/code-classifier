class Solution {

    public double method1(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int[] res = new int[m + n];
        int i = 0;
        int j = 0;
        int k = 0;
        // Keep comparing elements of 2 lists given and store the smaller number in the resultant list.
        while (i <= m - 1 && j <= n - 1) {
            if (nums1[i] <= nums2[j]) {
                res[k] = nums1[i];
                i++;
                k++;
            } else {
                res[k] = nums2[j];
                j++;
                k++;
            }
        }
        // If nums2 doesn\'t have anymore elements to compare,
        // simply insert the remaining elements of nums1 in the resultant list.
        while (i <= m - 1) {
            res[k] = nums1[i];
            i++;
            k++;
        }
        // Similarly, If nums1 doesn\'t have anymore elements to compare,
        // simply insert the remaining elements of nums2 in the resultant list.
        while (j <= n - 1) {
            res[k] = nums2[j];
            j++;
            k++;
        }
        // Find median and return.
        double var1 = 0;
        for (int z = 0; z <= k - 1; z++) {
            // If num of elements is odd, simply return the middle value.
            if (k % 2 != 0) {
                var1 = res[(k - 1) / 2];
            } else // If num of elements is even, add the 2 middle value and divide by 2. Typecast to double so that the divsion happens in floating point.
            {
                var1 = (double) (res[k / 2] + res[(k / 2) - 1]) / 2;
            }
        }
        return var1;
    }
}
