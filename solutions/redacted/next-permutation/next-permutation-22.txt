class Solution {

    public void method1(int[] nums) {
        int indexPoint = -1;
        // Step 1: Find the first decreasing element
        for (int i = nums.length - 1; i > 0; i--) {
            if (nums[i - 1] < nums[i]) {
                indexPoint = i - 1;
                break;
            }
        }
        // If no valid indexPoint is found, it means we\'re at the last permutation
        if (indexPoint >= 0) {
            // Initialize numberToSwap
            int numberToSwap = nums[indexPoint + 1];
            int indexOfnumberToSwap = indexPoint + 1;
            // Step 3: Find the rightmost successor
            for (int i = indexPoint + 1; i < nums.length; i++) {
                if (nums[i] > nums[indexPoint] && nums[i] <= numberToSwap) {
                    numberToSwap = nums[i];
                    indexOfnumberToSwap = i;
                }
            }
            // Swap the found elements
            int temp = nums[indexOfnumberToSwap];
            nums[indexOfnumberToSwap] = nums[indexPoint];
            nums[indexPoint] = temp;
        }
        // Step 4: Sort the suffix starting from indexPoint + 1
        Arrays.sort(nums, indexPoint + 1, nums.length);
        // Handle case where we did not find a valid next permutation
        if (indexPoint == -1) {
            // Sort the entire array if we are at the last permutation
            Arrays.sort(nums);
        }
    }
}
