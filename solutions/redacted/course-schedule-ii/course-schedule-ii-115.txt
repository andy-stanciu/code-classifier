class Solution {

    public int[] findOrder(int n, int[][] pre) {
        int m = pre.length;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 0; i < m; i++) {
            adj.get(pre[i][1]).add(pre[i][0]);
        }
        boolean[] vis = new boolean[n];
        boolean[] pathVis = new boolean[n];
        Stack<Integer> st = new Stack<>();
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(i, vis, pathVis, st, adj);
            }
        }
        int i = 0;
        int[] ans = new int[n];
        while (!st.isEmpty()) {
            ans[i++] = st.pop();
        }
        if (i == n)
            return ans;
        int[] a = {};
        return a;
        // BFS
        // int[] indeg = new int[n];
        // for(int i = 0; i<n; i++){
        //     for(int it: adj.get(i)){
        //         indeg[it]++;
        //     }
        // }
        // Queue<Integer> q = new LinkedList<>();
        // for(int i = 0; i<n; i++){
        //     if(indeg[i] == 0) q.offer(i);
        // }
        // int[] ls = new int[n];
        // int i = 0;
        // while(!q.isEmpty()){
        //     int node = q.poll();
        //     ls[i++] = node;
        //     for(int it: adj.get(node)){
        //         indeg[it]--;
        //         if(indeg[it] == 0) q.offer(it);
        //     }
        // }
        // if(i == n) return ls;
        // int[] a = {};
        // return a;
    }

    void dfs(int s, boolean[] vis, boolean[] pathVis, Stack<Integer> st, ArrayList<ArrayList<Integer>> adj) {
        vis[s] = true;
        pathVis[s] = true;
        for (int it : adj.get(s)) {
            if (!vis[it]) {
                dfs(it, vis, pathVis, st, adj);
            } else if (pathVis[it]) {
                return;
            }
        }
        pathVis[s] = false;
        st.push(s);
    }
}
