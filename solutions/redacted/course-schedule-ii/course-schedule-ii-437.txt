class Solution {

    boolean cycleFound = false;

    int[] updateVisited;

    public int[] findOrder(int n, int[][] p) {
        int[] ans = new int[n];
        int[] visited = new int[n];
        updateVisited = new int[n];
        Stack<Integer> stack = new Stack<>();
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) map.put(i, new ArrayList<>());
        for (int[] arr : p) {
            map.get(arr[1]).add(arr[0]);
        }
        for (int i = 0; i < n; i++) {
            if (visited[i] == 0) {
                dfs(i, stack, map, visited);
            }
        }
        int i = 0;
        while (!stack.isEmpty()) {
            ans[i++] = stack.pop();
        }
        return cycleFound ? new int[] {} : ans;
    }

    public void dfs(int i, Stack<Integer> stack, Map<Integer, List<Integer>> map, int[] visited) {
        if (visited[i] == 1)
            return;
        visited[i] = 1;
        updateVisited[i] = 1;
        for (int link : map.get(i)) {
            if (visited[link] == 0) {
                dfs(link, stack, map, visited);
            } else {
                if (updateVisited[link] == 1)
                    cycleFound = true;
            }
        }
        updateVisited[i] = 0;
        stack.push(i);
    }
}
