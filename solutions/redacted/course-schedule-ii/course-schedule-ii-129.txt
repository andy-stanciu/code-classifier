class Solution {

    static class edge {

        int src;

        int dest;

        public edge(int src, int dest) {
            this.src = src;
            this.dest = dest;
        }
    }

    static void create(ArrayList<edge>[] graph, int[][] que) {
        for (int i = 0; i < graph.length; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int i = 0; i < que.length; i++) {
            graph[que[i][0]].add(new edge(que[i][0], que[i][1]));
        }
    }

    static boolean cycle(ArrayList<edge>[] graph, boolean[] visit, int curr, boolean[] stack) {
        visit[curr] = true;
        stack[curr] = true;
        for (int i = 0; i < graph[curr].size(); i++) {
            edge e = graph[curr].get(i);
            if (stack[e.dest])
                return true;
            if (!visit[e.dest] && cycle(graph, visit, e.dest, stack))
                return true;
        }
        stack[curr] = false;
        visit[curr] = false;
        return false;
    }

    static void bfs(ArrayList<edge>[] graph, boolean[] visit, int curr, Stack<Integer> s) {
        visit[curr] = true;
        for (int i = 0; i < graph[curr].size(); i++) {
            edge e = graph[curr].get(i);
            if (!visit[e.dest]) {
                bfs(graph, visit, e.dest, s);
            }
        }
        s.push(curr);
    }

    public int[] findOrder(int param1, int[][] prerequisites) {
        ArrayList<edge>[] graph = new ArrayList[param1];
        create(graph, prerequisites);
        boolean[] visit = new boolean[graph.length];
        Stack<Integer> s = new Stack<>();
        boolean[] stack = new boolean[param1];
        boolean[] isvisit = new boolean[graph.length];
        for (int i = 0; i < param1; i++) {
            if (!visit[i])
                if (cycle(graph, visit, i, stack)) {
                    return new int[0];
                }
            if (!visit[i])
                bfs(graph, visit, i, s);
        }
        int[] arr = new int[s.size()];
        int i = s.size() - 1;
        while (!s.isEmpty()) {
            arr[i] = s.pop();
            i--;
        }
        return arr;
    }
}
