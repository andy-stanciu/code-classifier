class Solution {

    public int[] findOrder(int param1, int[][] prerequisites) {
        List<Integer> paths = new ArrayList<>();
        int[] visited = new int[param1];
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < param1; i++) {
            graph.add(new ArrayList<>());
        }
        for (int[] prerequisite : prerequisites) {
            List<Integer> adjacentNodes = graph.get(prerequisite[0]);
            adjacentNodes.add(prerequisite[1]);
        }
        Set<Integer> destinations = new HashSet<>();
        graph.forEach(destinations::addAll);
        List<Integer> starts = new ArrayList<>();
        for (int i = 0; i < param1; i++) {
            if (!destinations.contains(i)) {
                starts.add(i);
            }
        }
        AtomicBoolean hasCycle = new AtomicBoolean(false);
        for (int i : starts) {
            if (visited[i] == 0) {
                visited[i] = 1;
                dfs(graph, visited, i, hasCycle, paths);
                visited[i] = 2;
                paths.add(i);
                if (hasCycle.get()) {
                    return new int[] {};
                }
            }
        }
        if (paths.size() != param1) {
            return new int[] {};
        }
        return paths.stream().mapToInt(Integer::intValue).toArray();
    }

    private void dfs(List<List<Integer>> graph, int[] visited, int i, AtomicBoolean hasCycle, List<Integer> paths) {
        for (int adjacent : graph.get(i)) {
            if (visited[adjacent] == 0) {
                visited[adjacent] = 1;
                dfs(graph, visited, adjacent, hasCycle, paths);
            } else if (visited[adjacent] == 1) {
                hasCycle.set(true);
            }
            if (visited[adjacent] != 2) {
                paths.add(adjacent);
            }
            visited[adjacent] = 2;
        }
    }
}
