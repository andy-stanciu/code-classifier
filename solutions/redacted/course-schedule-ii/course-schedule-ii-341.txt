class Solution {

    /*

    Step 1: Create HashMap and List with CourseNode
    Step 2: Add prereqs to each course in the input. HashMap is used only here to fetch course nodes.
    Step 3: Use List with couse nodes to begin DFS
    Step 4: returned List with ording will be in reverse order since the last one will be added first during DFS
    Step 5: just reverse the order from DFS list return to int[] and return

    */
    Map<Integer, Class1> var1 = new HashMap<>();

    List<Class1> var2 = new ArrayList<>();

    public int[] findOrder(int param1, int[][] prerequisites) {
        List<Integer> result = new ArrayList<>();
        // just build map with nodes and list with node
        for (int i = 0; i < param1; i++) {
            // this is required only during building prereqs for each course
            var1.put(i, new Class1(i));
            // this required only to iterate for DFS
            var2.add(var1.get(i));
        }
        //adding prereqs to each course
        for (int i = 0; i < prerequisites.length; i++) {
            int var3 = prerequisites[i][1];
            int dep = prerequisites[i][0];
            if (!var1.containsKey(var3))
                var1.put(var3, new Class1(var3));
            if (!var1.containsKey(dep))
                var1.put(dep, new Class1(dep));
            Class1 var4 = var1.get(var3);
            Class1 depNode = var1.get(dep);
            var4.preReqs.add(depNode);
        }
        // actual dfs starts here
        while (var2.size() > 0) {
            Class1 node = var2.get(var2.size() - 1);
            var2.remove(var2.size() - 1);
            boolean isCyclic = dfs(node, result);
            if (isCyclic)
                return new int[0];
        }
        // this is to order the courses since the last one will be added first in DFS
        int[] res = new int[result.size()];
        for (int i = 0, j = result.size() - 1; i < result.size(); i++, j--) {
            res[i] = result.get(j);
        }
        return res;
    }

    public boolean dfs(Class1 node, List<Integer> result) {
        if (node.visited)
            return false;
        if (node.visiting)
            return true;
        node.visiting = true;
        for (Class1 prereq : node.preReqs) {
            boolean isCyclic = dfs(prereq, result);
            if (isCyclic)
                return true;
        }
        node.visited = true;
        node.visiting = false;
        result.add(node.val);
        return false;
    }

    class Class1 {

        int val;

        boolean visited;

        boolean visiting;

        List<Class1> preReqs;

        Class1(int val) {
            this.val = val;
            this.preReqs = new ArrayList<>();
            this.visited = false;
            this.visiting = false;
        }
    }
}
