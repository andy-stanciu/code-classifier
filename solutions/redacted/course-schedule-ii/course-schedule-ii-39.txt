/*Just a minor change from Course schedule 1 */
class Solution {

    HashMap<Integer, List<Integer>> adjList;

    public int[] findOrder(int param1, int[][] prerequisites) {
        int[][] var1 = prerequisites;
        adjList = new HashMap<>();
        ArrayList<Integer> order = new ArrayList<>();
        int[] states = new int[param1];
        for (int[] var2 : var1) {
            int a = var2[0];
            int b = var2[1];
            if (!adjList.containsKey(a)) {
                adjList.put(a, new ArrayList<Integer>());
            }
            adjList.get(a).add(b);
        }
        for (int var2 = 0; var2 < param1; var2++) {
            if (!dfs(var2, order, states)) {
                //if any of the nodes returned false, we immediately return false.
                return new int[0];
            }
        }
        return order.stream().mapToInt(Integer::intValue).toArray();
    }

    private boolean dfs(int var2, ArrayList order, int[] states) {
        //we found a cycle.
        if (states[var2] == 1)
            return false;
        //this node/course is good to be taken.
        if (states[var2] == 2)
            return true;
        //mark it visiting first.
        states[var2] = 1;
        if (adjList.containsKey(var2)) {
            //it is important, what if there was a node with no neighbors
            for (int neighbor : adjList.get(var2)) {
                if (!dfs(neighbor, order, states)) {
                    return false;
                }
            }
        }
        order.add(var2);
        states[var2] = 2;
        return true;
    }
}
