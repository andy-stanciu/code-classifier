/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    // O(m+n)     where n = |list1|, m = |list2|
    // Decreasing Recurrence Function
    public ListNode method1(ListNode list1, ListNode list2) {
        // T(n)-1
        // If both Nodes are not null, choose the Node
        // with the lesser value and recall the function
        // in a recursive way by *decreasing* n by 1.
        // The decrease is done by recalling the function and
        // changing the parameter referring to the chosen Node
        // to its .next
        if (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                // list1\'s val is lesser than list2\'s
                // Next call I will check the lesser one between
                // its .next Node and the same list2 Node
                list1.next = method1(list1.next, list2);
                return list1;
            } else {
                list2.next = method1(list1, list2.next);
                return list2;
            }
        }
        // BASE CASE    O(1)
        // At least one Node is null: return the non-null Node
        // even if that node is not the last of its chain, the
        // next nodes are already connected to it by its .next
        // method, so there is no need to continue.
        if (list1 == null)
            return list2;
        return list1;
    }
}
