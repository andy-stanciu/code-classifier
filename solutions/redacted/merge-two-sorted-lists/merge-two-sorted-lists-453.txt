/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode method1(ListNode list1, ListNode list2) {
        // Base case: if both lists are empty, return null (nothing to merge)
        if (list1 == null && list2 == null) {
            return null;
        } else // If list1 is empty, return list2 (remaining elements of list2 will be the result)
        if (list1 == null && list2 != null) {
            return list2;
        } else // If list2 is empty, return list1 (remaining elements of list1 will be the result)
        if (list1 != null && list2 == null) {
            return list1;
        }
        // Create a new node for the merged list, select the smaller value between list1 and list2
        ListNode newHead = new ListNode(list1.val <= list2.val ? list1.val : list2.val);
        // Recursively merge the remaining elements of the two lists
        // If list1\'s value is smaller, move to list1.next and keep list2 unchanged
        // Otherwise, move to list2.next and keep list1 unchanged
        newHead.next = list1.val <= list2.val ? method1(list1.next, list2) : method1(list1, list2.next);
        // Return the new head of the merged list
        return newHead;
    }
}
