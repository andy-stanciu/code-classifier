/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Idea: Use current,previous and next pointers for reversing links and update the left anf right node after reversal of k nodes
 *  Run the abive logic for (linkedlistlength)/k times.
 */
class Solution {

    public ListNode method1(ListNode head, int k) {
        if (head.next == null) {
            return head;
        }
        ListNode tmp = head;
        int l = 0;
        while (tmp != null) {
            l++;
            tmp = tmp.next;
        }
        int sub = l / k;
        ListNode nh = null;
        ListNode ln = head;
        ListNode lnp = null;
        ListNode curr = head;
        ListNode prev = null;
        tmp = head;
        ListNode next = head.next;
        l = 0;
        while (sub-- > 0) {
            int i = 1;
            while (i <= k) {
                curr.next = prev;
                prev = curr;
                curr = next;
                if (curr != null)
                    next = curr.next;
                else
                    next = null;
                i++;
            }
            ln.next = curr;
            if (l == 0) {
                nh = prev;
            }
            l++;
            if (lnp != null)
                lnp.next = prev;
            prev = ln;
            ln = curr;
            lnp = prev;
        }
        return nh;
    }
}
