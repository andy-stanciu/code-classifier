class Solution {

    private List<List<String>> partitions = new ArrayList<>();

    public List<List<String>> partition(String s) {
        int n = s.length();
        // dp[i][j] == true if s[i:j] is a palindrome
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
            if (i < n - 1 && s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
            }
        }
        for (int k = 2; k < n; k++) {
            for (int i = 0, j = i + k; j < n; i++, j++) {
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                }
            }
        }
        backtracking(0, 0, s, dp, new ArrayList<String>());
        return partitions;
    }

    private void backtracking(int curr, int prev, String s, boolean[][] dp, List<String> partition) {
        if (curr == s.length()) {
            if (prev == s.length()) {
                partitions.add(new ArrayList<>(partition));
            }
            return;
        }
        if (dp[prev][curr]) {
            partition.add(s.substring(prev, curr + 1));
            backtracking(curr + 1, curr + 1, s, dp, partition);
            partition.remove(partition.size() - 1);
        }
        backtracking(curr + 1, prev, s, dp, partition);
    }
}
